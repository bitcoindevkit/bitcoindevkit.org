[
{
	"uri": "https://test.bitcoindevkit.org/repl/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Requirements The only requirement is a Linux/macOS system with a fairly recent Rust toolchain installed. Since Linux distros tend to lag behind with updates, the quickest way to install the Rust compiler and Cargo is rustup.rs. You can head there and follow their instructions, after which you can test if everything went fine by running cargo version, which should print something like:\ncargo 1.45.0 (744bd1fbb 2020-06-15) At the time of writing, the project requires cargo \u0026gt;= 1.45.0, which is the latest stable as of June 2020. If you have an older version installed with rustup.rs, you can upgrade it with rustup update.\nIf you really don\u0026rsquo;t want to pipe the output of curl into sh, you can also try using a Docker image and working inside of it, but that\u0026rsquo;s meant for more advanced users and won\u0026rsquo;t be covered in this guide.\nInstalling BDK repl Once Cargo is installed, you can proceed to install the interactive BDK repl tool directly from the GitHub repository, by running:\ncargo install --git https://github.com/bitcoindevkit/bdk --features=cli-utils --example repl This command will probably take a while to finish, since it will fetch and compile all the dependencies and the bdk library itself. Once it\u0026rsquo;s done, you can check if everything went fine by running repl --help which should print something like this:\nMagical Bitcoin Wallet 0.1.0 Riccardo Casatta \u0026lt;riccardo@casatta.it\u0026gt;:Alekos Filini \u0026lt;alekos.filini@gmail.com\u0026gt; A modern, lightweight, descriptor-based wallet USAGE: repl [FLAGS] [OPTIONS] --descriptor \u0026lt;DESCRIPTOR\u0026gt; [SUBCOMMAND] FLAGS: -h, --help Prints help information -v Sets the level of verbosity -V, --version Prints version information OPTIONS: -c, --change_descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for internal addresses -d, --descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for the external addresses -n, --network \u0026lt;NETWORK\u0026gt; Sets the network [default: testnet] [possible values: testnet, regtest] -s, --server \u0026lt;SERVER:PORT\u0026gt; Sets the Electrum server to use [default: tn.not.fyi:55001] -w, --wallet \u0026lt;WALLET_NAME\u0026gt; Selects the wallet to use [default: main] SUBCOMMANDS: broadcast Extracts the finalized transaction from a PSBT and broadcasts it to the network create_tx Creates a new unsigned tranasaction get_balance Returns the current wallet balance get_new_address Generates a new external address help Prints this message or the help of the given subcommand(s) list_unspent Lists the available spendable UTXOs policies Returns the available spending policies for the descriptor repl Opens an interactive shell sign Signs and tries to finalize a PSBT sync Syncs with the chosen Electrum server An example command to sync a testnet wallet looks like this:\nrepl --descriptor \u0026quot;wpkh(tprv8ZgxMBicQKsPexGYyaFwnAsCXCjmz2FaTm6LtesyyihjbQE3gRMfXqQBXKM43DvC1UgRVv1qom1qFxNMSqVAs88qx9PhgFnfGVUdiiDf6j4/0/*)\u0026quot; --network testnet --server tcp://testnet.aranguren.org:51001 sync "
},
{
	"uri": "https://test.bitcoindevkit.org/repl/",
	"title": "REPL",
	"tags": [],
	"description": "",
	"content": "REPL The bdk repo has a very minimalistic interactive shell called repl that acts both as a reference implementation of a wallet and a tool to quickly experiment with descriptors and transactions.\n"
},
{
	"uri": "https://test.bitcoindevkit.org/repl/concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "Now, in order to better grasp some of the design choices made by BDK, it\u0026rsquo;s important to understand the main concept driving the development of this project, and the goal that it\u0026rsquo;s trying to achieve.\nBDK is aiming first of all to be a set of libraries and tools, all meant to be very reusable and adaptable. Developers working on their own wallets or other projects that are trying to integrate Bitcoin can pick the tools they need and piece them together to prototype and quickly ship a working product. This means that the REPL that we\u0026rsquo;ve just installed is designed to be a very thin layer over the APIs exposed by the various components of the library, not a full, end-user-ready Bitcoin wallet.\nThis concept leads to a few design choices that are arguably very bad for the \u0026ldquo;UX\u0026rdquo; of this wallet, but that allow developers to work more directly with the underlying library. For instance:\n BDK has an internal database that\u0026rsquo;s used to store data about received transactions, spendable UTXOs, etc. This database is stored by default in your home folder, in ~/.bdk-bitcoin. The database will never contain any data that can\u0026rsquo;t be recreated purely by looking at the blockchain. Keys, descriptors, Electrum endpoints are not stored in there. This explains why you\u0026rsquo;ll have to specify them every time in the command line. It can be seen more like a cache and can be safely deleted without risking funds. BDK doesn\u0026rsquo;t automatically \u0026ldquo;monitor\u0026rdquo; the blockchain, instead there\u0026rsquo;s a sync command that has to be called by the user. When you create a transaction and then sign it, it\u0026rsquo;s not automatically broadcast to the network. There\u0026rsquo;s a broadcast command that does this. Moreover, the command doesn\u0026rsquo;t accept a normal Bitcoin raw transaction, but instead a PSBT. That\u0026rsquo;s because internally transactions are always moved as PSBTs, and again, the broadcast command is just a very thin wrapper over the raw library call.  There are probably more of these examples, but hopefully by this point you\u0026rsquo;ll have more or less understood the gist of it. If you are not a developer, some parts of this will feel weird, inefficient, hard to understand, and that\u0026rsquo;s absolutely normal. Just try to survive through the pain and you\u0026rsquo;ll be rewarded!\n"
},
{
	"uri": "https://test.bitcoindevkit.org/repl/interface/",
	"title": "Interface",
	"tags": [],
	"description": "",
	"content": "Remember the repl --help command you ran before? Let\u0026rsquo;s analyze its output here to figure out the interface:\nFlags FLAGS: -h, --help Prints help information -v Sets the level of verbosity -V, --version Prints version information These are the optional flags that can be set with every command. The -h flag prints the help message, the -V flag only prints the version and the -v is actually ignored at the moment.\nVerbosity If you want to increase the verbosity of the output, you should use the RUST_LOG environment variable. You can set it like so to see a lot more of what\u0026rsquo;s going on behind the scenes, before running the repl command. You only have to do this once when you open a new shell, after that you can run the repl command multiple times.\nexport RUST_LOG=\u0026#34;bdk=debug\u0026#34; Options OPTIONS: -c, --change_descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for internal addresses -d, --descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for the external addresses -n, --network \u0026lt;NETWORK\u0026gt; Sets the network [default: testnet] [possible values: testnet, regtest] -s, --server \u0026lt;SERVER:PORT\u0026gt; Sets the Electrum server to use [default: ssl://electrum.blockstream.info:60002] -w, --wallet \u0026lt;WALLET_NAME\u0026gt; Selects the wallet to use [default: main] -p, --proxy \u0026lt;SERVER:PORT\u0026gt; Sets the SOCKS5 proxy for the Electrum client These are the global options that can be set. They are pretty much like the flags, but they also take a value. The only required one is the --descriptor or -d flag, since every wallet must have an associated descriptor.\nThe --change-descriptor flag can be used to set a different descriptor for the change addresses, sometimes called \u0026ldquo;internal\u0026rdquo; addresses in Bitcoin Core. Unfortunately there isn\u0026rsquo;t really consensus on a nice way to encode information about the change derivation inside the standard descriptor, so we are stuck with having two separate ones. Keep in mind though, that even if you don\u0026rsquo;t specify a change descriptor, you\u0026rsquo;ll still be able to create transactions - the change address will simply be generated from the standard descriptor.\nThe --network flag can be used to change the network. Right now only testnet and regtest are supported since the code is very much not production-ready yet.\nThe --server flag can be used to select the Electrum server to use. By default it\u0026rsquo;s connecting to Blockstream\u0026rsquo;s electrum servers, which seems pretty stable. If you are having connection issues, you can also try with one of the other servers listed here and see if you have more luck with those. Right now both plaintext and ssl servers are supported (prefix tcp:// or no prefix at all for tcp, prefix ssl:// for ssl).\nThe --proxy flag can be optionally used to specify a SOCKS5 proxy to use when connecting to the Electrum server. Spawning a local Tor daemon and using it as a proxy will allow you to connect to .onion Electrum URLs. Keep in mind that only plaintext server are supported over a proxy\nThe --wallet flag can be used to select which wallet to use, if you have more than one of them. If you get a ChecksumMismatch error when you make some changes to your descriptor, it\u0026rsquo;s because it does not match anymore the one you\u0026rsquo;ve used to initialize the cache. One solution could be to switch to a new wallet name, or delete the cache directory at ~/.bdk and start from scratch.\nSubcommands    Command Description     broadcast Broadcasts a transaction to the network. Takes either a raw transaction or a PSBT to extract   combine_psbt Combines multiple PSBTs into one   create_tx Creates a new unsigned tranasaction   extract_psbt Extracts a raw transaction from a PSBT   finalize_psbt Finalizes a psbt   get_balance Returns the current wallet balance   get_new_address Generates a new external address   list_transactions Lists all the incoming and outgoing transactions of the wallet   list_unspent Lists the available spendable UTXOs   policies Returns the available spending policies for the descriptor   public_descriptor Returns the public version of the wallet\u0026rsquo;s descriptor(s)   repl Opens an interactive shell   sign Signs and tries to finalize a PSBT   sync Syncs with the chosen Electrum server    These are the main \u0026ldquo;functions\u0026rdquo; of the wallet. Most of them are pretty self explanatory, but we\u0026rsquo;ll go over them quickly anyways. You can get more details about every single command by running repl \u0026lt;subcommand\u0026gt; --help.\nbroadcast OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to extract and broadcast --tx \u0026lt;RAWTX\u0026gt; Sets the raw transaction to broadcast Broadcasts a transaction. The transaction can be a raw hex transaction or a PSBT, in which case it also has to be \u0026ldquo;finalizable\u0026rdquo; (i.e. it should contain enough partial signatures to construct a finalized valid scriptsig/witness).\ncombine_psbt OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt;... Add one PSBT to comine. This option can be repeated multiple times, one for each PSBT Combines multiple PSBTs by merging metadata and partial signatures. It can be used to merge multiple signed PSBTs into a single PSBT that contains every signature and is ready to be finalized.\ncreate_tx FLAGS: -a, --send_all Sends all the funds (or all the selected utxos). Requires only one addressees of value 0 OPTIONS: -f, --fee_rate \u0026lt;SATS_VBYTE\u0026gt; Fee rate to use in sat/vbyte --policy \u0026lt;POLICY\u0026gt; Selects which policy will be used to satisfy the descriptor --to \u0026lt;ADDRESS:SAT\u0026gt;... Adds an addressee to the transaction --unspendable \u0026lt;TXID:VOUT\u0026gt;... Marks an utxo as unspendable --utxos \u0026lt;TXID:VOUT\u0026gt;... Selects which utxos *must* be spent Creates a new unsigned PSBT. The flags allow to set a custom fee rate (the default is 1.0 sat/vbyte) with --fee_rate or -f, the list of UTXOs that should be considered unspendable with --unspendable (this option can be specified multiple times) and a list of UTXOs that must be spent with --utxos (again, this option can also be specified multiple times).\nThe --to option sets the receiver address of the transaction, and should contain the address and amount in Satoshi separated by a colon, like: --to --to 2NErbQPsooXRatRJdrXDm9wKR2fRiZDT9wL:50000. This option can also be specified multiple times to send to multiple addresses at once.\nThe --send_all flag can be used to send the value of all the spendable UTXOs to a single address, without creating a change output. If this flag is set, there must be only one --to address, and its value will be ignored (it can be set to 0).\nThe --policy option is an advanced flag that can be used to select the spending policy that the sender intends to satisfy in this transaction. It\u0026rsquo;s normally not required if there\u0026rsquo;s no ambiguity, but sometimes with complex descriptor it has to be specified, or you\u0026rsquo;ll get a SpendingPolicyRequired error. This flag should be set to an array of the list of child indexes that should be taken at each step when traversing the spending policies tree from the root, at least until there are no more ambiguities. This is probably better explained with an example:\nLet\u0026rsquo;s assume our descriptor is: sh(thresh(2,pk(A),sj:and_v(v:pk(B),n:older(6)),snj:and_v(v:pk(C),after(630000)))). There are three conditions and we need to satisfy two of them to be able to spend. The conditions are:\n Sign with the key corresponding to pk(A) Sign with the key corresponding to pk(B) AND wait 6 blocks Sign with the key corresponding to pk(C) AND wait that block 630,000 is reached  So if we write down all the possible outcomes when we combine them, we get:\n Sign with pk(A) + pk(B) + wait 6 blocks Sign with pk(A) + pk(C) + wait block 630,000 Sign with pk(B) + pk(C) + wait 6 blocks + wait block 630,000  In other words:\n If we choose option #1, the final transaction will need to have the nSequence of its inputs set to a value greather than or equal to 6, but the nLockTime can stay at 0. If we choose option #2, the final transaction will need to have its nLockTime set to a value greater than or equal to 630,000, but the nSequence can be set to a final value. If we choose option #3, both the nSequence and nLockTime must be set.  The wallet can\u0026rsquo;t choose by itself which one of these combination to use, so the user has to provide this information with the --policy flag.\nNow, let\u0026rsquo;s draw the condition tree to understand better how the chosen policy is represented: every node has its id shown right next to its name, like qd3um656 for the root node. These ids can be seen by running the policies command. Some ids have been omitted since they are not particularly relevant, in this example we will actually only use the root id.\ngraph TD; subgraph \" \" R[\"Root - qd3um656\"] -- A[\"pk(A) - ykfuwzkl\"] R[\"Root - qd3um656\"] -- B[\"B - ms3xjley\"] B[\"B - ms3xjley\"] -- B_0[\"pk(B)\"] B[\"B - ms3xjley\"] -- B_1[\"older(6)\"] end C[\"C - d8jph6ax\"] -- C_0[\"pk(C)\"] C[\"C - d8jph6ax\"] -- C_1[\"after(630,000)\"] R[\"Root - qd3um656\"] -- C[\"C - d8jph6ax\"]  Let\u0026rsquo;s imagine that we are walking down from the root, and we want to use option #1. So we will have to select pk(A) + the whole B node. Since these nodes have an id, we can use it to refer to them and say which children we want to use. In this case we want to use children #0 and #1 of the root, so our final policy will be: --policy {\u0026quot;qd3um656\u0026quot;:[0,1]}.\nextract_psbt OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to extract Extracts the global transaction from a PSBT. Note that partial signatures are ignored in this step. If you want to merge the partial signatures back into the global transaction first, please use finalize_psbt first\nfinalize_psbt OPTIONS: --assume_height \u0026lt;HEIGHT\u0026gt; Assume the blockchain has reached a specific height --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to finalize Tries to finalize a PSBT by merging all the partial signatures and other elements back into the global transaction. This command fails if there are timelocks that have not yet expired, but the check can be overridden by specifying --assume_height to make the wallet assume that a future height has already been reached.\nget_balance This subcommand has no extra flags, and simply returns the available balance in Satoshis. This command should normally be called after sync, since it only looks into the local cache to determine the list of UTXOs.\nget_new_address This subcommand has no extra flags and returns a new address. It internally increments the derivation index and saves it in the database.\nlist_transactions This subcommand has no extra flags and returns the history of transactions made or received by the wallet, with their txid, confirmation height and the amounts (in Satoshi) \u0026ldquo;sent\u0026rdquo; (meaning, the sum of the wallet\u0026rsquo;s inputs spent in the transaction) and \u0026ldquo;received\u0026rdquo; (meaning, the sum of the outputs received by the wallet). Just like get_balance it should normally be called after sync, since it only operates on the internal cache.\nlist_unspent This subcommand has no extra flags and returns the list of available UTXOs and their value in Satoshi. Just like get_balance it should normally be called after sync, since it only operates on the internal cache.\npolicies This subcommand has no extra flags and returns the spending policies encoded by the descriptor in a more human-readable format. As an example, running the policies command on the descriptor shown earlier for the in the explanation of the create_tx command, it will return this:\n This is a tree-like recursive structure, so it tends to get huge as more and more pieces are added, but it\u0026rsquo;s in fact fairly simple. Let\u0026rsquo;s analyze a simple node of the tree:\n{ \u0026#34;id\u0026#34;:\u0026#34;qd3um656\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;SIGNATURE\u0026#34;, \u0026#34;pubkey\u0026#34;:\u0026#34;...\u0026#34;, \u0026#34;satisfaction\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;NONE\u0026#34; }, \u0026#34;contribution\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;COMPLETE\u0026#34;, \u0026#34;condition\u0026#34;:{} } }   id is a unique identifier to this specific node in the tree.\n  type, as the name implies, represents the type of node. It defines what should be provided to satisfy that particular node. Generally some other data are provided to give meaning to the type itself (like the pubkey field here in the example). There are basically two families of types: some of them can only be used as leaves, while some other can only be used as intermediate nodes.\nPossible leaf nodes are:\n SIGNATURE, requires a signature made with the specified key. Has a pubkey if it\u0026rsquo;s a single key, a fingerprint if the key is an xpub, or a pubkey_hash if the full public key is not present in the descriptor. SIGNATUREKEY, requires a signature plus the raw public key. Again, it can have a pubkey, fingerprint or pubkey_hash. SHA256PREIMAGE, requires the preimage of a given hash. HASH256PREIMAGE, requires the preimage of a given hash. RIPEMD160PREIMAGE, requires the preimage of a given hash. HASH160PREIMAGE, requires the preimage of a given hash. ABSOLUTETIMELOCK, doesn\u0026rsquo;t technically require anything to be satisfied, just waiting for the timelock to expire. Has a value field with the raw value of the timelock (can be both in blocks or time-based). RELATIVETIMELOCK, again only requires waiting for the timelock to expire. Has a value like ABSOLUTETIMELOCK.  Possible non-leaf nodes are:\n THRESH, defines a threshold of policies that has to be met to satisfy the node. Has an items field, which is a list of policies to satisfy and a threshold field that defines the threshold. MULTISIG, Similar to THRESH, has a keys field, which is a list of keys represented again as either pubkey, fingerprint or pubkey_hash and a threshold field.    satisfaction is currently not implemented and will be used to provide PSBT introspection, like understanding whether or not a node is already satisfied and to which extent in a PSBT.\n  contribution represents if so and how much, the provided descriptor can contribute to the node.\nThe possible types are:\n NONE, which means that the descriptor cannot contribute. COMPLETE, which means that the descriptor by itself is enough to completely satisfy the node. It also adds a condition field which represent any potential extra condition that has to be met to consider the node complete. An example are the timelock nodes, that are always complete but they have an extra csv or timelock condition. PARTIAL, which means that the descriptor can partially satisfy the descriptor. This adds a m, n, items that respectively represent the threshold, the number of available items to satisfy and the items that the provided descriptor can satisfy. Also adds a conditions field which is an integer to list of conditions map. The key is the child index and the map are all the possibile extra conditions that have to be satisfied if that node is used in the threshold. For instance, if you have a threshold of a SIGNATURE and a RELATIVETIMELOCK, in this order, the conditions field will be 1 ‚áí csv(x), because the item at index 1 needs the extra csv condition. PARTIALCOMPLETE, which is basically a PARTIAL with the size of items \u0026gt;= m. It\u0026rsquo;s treated as a separate entity to make the code a bit more clean and easier to implement. Like PARTIAL, it also has a m, n, items fields but the conditions field is a bit different: it\u0026rsquo;s a list of integers to list of conditions map. The key represents the combination that can be used to satisfy the threshold, and the value contains all the possible conditions that also have to be satisfied. For instance, if you have a 2-of-2 threshold of a TIMELOCK and a RELATIVETIMELOCK, the conditions field will be [0, 1] ‚áí csv(x) + timelock(y), because if the combination of items 0 and 1 is picked, both of their conditions will have to be meet too.    While the structure contains all of the intermediate nodes too, the root node is the most important one because defines how the descriptor can contribute to spend outputs sent to its addresses.\nFor instance, looking at the root node of the previous example (with the internal items omitted) from a descriptor that has all the three private keys for keys A, B and C, we can clearly see that it can satisfy the descriptor (type = PARTIALCOMPLETE) and the three options are [0, 1] ‚áí csv(6) (Option #1), [0, 2] ‚áí timelock(630,000) (Option #2) or [1, 2] ‚áí csv(6) + timelock(630,000) (Option #3).\n{ \u0026#34;type\u0026#34;:\u0026#34;THRESH\u0026#34;, \u0026#34;items\u0026#34;:[], \u0026#34;threshold\u0026#34;:2, \u0026#34;satisfaction\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;NONE\u0026#34; }, \u0026#34;contribution\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;PARTIALCOMPLETE\u0026#34;, \u0026#34;n\u0026#34;:3, \u0026#34;m\u0026#34;:2, \u0026#34;items\u0026#34;:[ 0, 1, 2 ], \u0026#34;conditions\u0026#34;:{ \u0026#34;[0, 1]\u0026#34;:[ { \u0026#34;csv\u0026#34;:6 } ], \u0026#34;[0, 2]\u0026#34;:[ { \u0026#34;timelock\u0026#34;:630000 } ], \u0026#34;[1, 2]\u0026#34;:[ { \u0026#34;csv\u0026#34;:6, \u0026#34;timelock\u0026#34;:630000 } ] } } } public_descriptor This subcommand has no extra flags and returns the \u0026ldquo;public\u0026rdquo; version of the wallet\u0026rsquo;s descriptor(s). It can be used to bootstrap a watch-only instance for the wallet.\nrepl This subcommand has no extra flags and launches an interactive shell session.\nsign OPTIONS: --assume_height \u0026lt;HEIGHT\u0026gt; Assume the blockchain has reached a specific height. This affects the transaction finalization, if there are timelocks in the descriptor --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to sign Adds to the PSBT all the signatures it can produce with the secrets embedded in the descriptor (xprv or WIF keys). Returns the signed PSBT and, if there are enough item to satisfy the script, also the extracted raw Bitcoin transaction.\nOptionally, the assume_height option can be specified to let the wallet assume the blockchain has reached a specific height. This affects the finalization of the PSBT which is done right at the end of the signing process: the wallet tries to satisfy the spending condition of each input using the partial signatures collected. In case timelocks are present the wallet needs to know whether or not they have expired. This flag is particularly useful for offline wallets.\nsync This subcommand has no extra flags. It connects to the chosen Electrum server and synchronizes the list of transactions received and available UTXOs.\n"
},
{
	"uri": "https://test.bitcoindevkit.org/repl/regtest/",
	"title": "Regtest",
	"tags": [],
	"description": "",
	"content": "Running the REPL in regtest requires having a local Electrum server set-up. There are two main implementations, electrs in Rust and ElectrumX in Python. Since the Rust toolchain is already required to use BDK, this page will focus mostly on the former.\nElectrs can be installed by running:\ncargo install --git https://github.com/romanz/electrs --bin electrs Just like before, this command will probably take a while to finish.\nOnce it\u0026rsquo;s done, assuming you have a regtest bitcoind running in background, you can launch a new terminal and run the following command to actually start electrs:\nelectrs -vv --timestamp --db-dir /tmp/electrs-db --electrum-rpc-addr=\u0026#34;127.0.0.1:50001\u0026#34; --network=regtest --cookie-file=$HOME/.bitcoin/regtest/.cookie on macOS you should change the cookie-file to $HOME/Library/Application Support/Bitcoin/regtest/.cookie.\nThis will start the Electrum server on port 50001. You can then add the -n regtest -s localhost:50001 the repl commands to switch to the local regtest.\nTroubleshooting Stuck with \u0026ldquo;wait until bitcoind is synced (i.e. initialblockdownload = false)\u0026rdquo; Just generate a few blocks with bitcoin-cli generatetoaddress 1 \u0026lt;address\u0026gt;\nBonus: Docker If you have already installed Docker on your machine, you can also use üç£ Nigiri CLI to spin-up a complete development environment in regtest that includes a bitcoin node, an electrs explorer and the esplora web-app to visualize blocks and transactions in the browser.\nInstall üç£ Nigiri\n$ curl https://getnigiri.vulpem.com | bash Start Docker daemon and run Nigiri box\n$ nigiri start This will start electrum RPC interface on port 51401, the REST interface on 3000 and the esplora UI on 5000 (You can visit with the browser and look for blocks, addresses and transactions)\nYou can then add the -n regtest -s localhost:51401 to the repl commands to switch to the local regtest.\n"
},
{
	"uri": "https://test.bitcoindevkit.org/repl/compiler/",
	"title": "Compiler",
	"tags": [],
	"description": "",
	"content": "Introduction If you want to play around with more complicated spending policies, you\u0026rsquo;ll start to find it harder and harder to manually create the descriptors. This is where the miniscript compiler comes in! The bdk library includes a very simple compiler that can produce a descriptor given a spending policy. The syntax used to encode the spending policy is very well described in this page, specifically in the \u0026ldquo;Policy to Miniscript compiler\u0026rdquo;. The compiler included in BDK does basically the same job, but produces descriptors for rust-miniscript that have some minor differences from the ones made by the C++ implementation used in that website.\nInstallation To install the miniscript compiler run the following command:\ncargo install --git https://github.com/bitcoindevkit/bdk --features=\u0026#34;compiler\u0026#34; --example miniscriptc Once the command is done, you should have a miniscriptc command available. You can check if that\u0026rsquo;s the case by running miniscriptc --help.\nUsage In this case the interface is very simple: it accepts two arguments called \u0026ldquo;POLICY\u0026rdquo; and \u0026ldquo;TYPE\u0026rdquo;, in this order. The first one, as the name implies, sets the spending policy to compile. The latter defines the type of address that should be used to encapsulate the produced script, like a P2SH, P2WSH, etc.\nOptionally, the --parsed_policy flag can be enabled and it will make the compiler print the JSON \u0026ldquo;human-readable\u0026rdquo; version of the spending policy, as described in the policies subcommand of the CLI.\nThe --network flag can be used to change the network encoding of the address shown.\nKeep in mind that since the compiler loads and interprets the descriptor, all the public keys specified in the policy must be valid public keys. This differs from the web tool linked above that also accepts placeholders too. As described in the previous sections of this guide, the keys can be either xpub/xprv with or without metadata and a derivation path, WIF keys or raw hex public keys.\n Example Let\u0026rsquo;s take this policy for example:\nminiscriptc --parsed_policy and(pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR),or(50@pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),older(1000)))) sh-wsh The compiler should print something like:\n[2020-04-29T10:42:05Z INFO miniscriptc] Compiling policy: and(pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR),or(50@pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),older(1000))) [2020-04-29T10:42:05Z INFO miniscriptc] ... Descriptor: sh(wsh(and_v(or_c(c:pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),v:older(1000)),c:pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR)))) [2020-04-29T10:42:05Z INFO miniscriptc] ... First address: 2MsqrJuZewY3o3ADAy1Uhi5vsBqTANjH3Cf JSON policy:\n Troubleshooting Nothing is printed This might mean that you have a RUST_LOG variable set to a value that suppresses the compiler\u0026rsquo;s log. You can try adding miniscriptc=info to your RUST_LOG value and see if that works, or open a new clean shell.\n"
},
{
	"uri": "https://test.bitcoindevkit.org/descriptors/",
	"title": "Descriptors",
	"tags": [],
	"description": "",
	"content": "Descriptors are a compact and semi-standard way to easily encode, or \u0026ldquo;describe\u0026rdquo;, how scripts (and subsequently, addresses) of a wallet should be generated. They can be especially helpful when working with multisigs or even more complex scripts, where the structure of the script itself is not trivial. They are a big step forward in making wallets more portable across different tools and apps, because for the first time they create a common language to describe a full bitcoin script that developers can use and integrate in their software.\nThe ecosystem around descriptors is still very much in its early stage, but they are starting to see some adoption in Bitcoin Core and other projects. BDK aims to produce the first \u0026ldquo;Native Descriptor\u0026rdquo; Bitcoin library that can be used by developers to build their own \u0026ldquo;Native Descriptor Wallets\u0026rdquo;.\nCompatibility Matrix Below are some tables to highlight the differences between Bitcoin Core\u0026rsquo;s descriptor support, rust-miniscript\u0026rsquo;s one and BDK\u0026rsquo;s.\nKey Types    Key Type BDK rust-miniscript Bitcoin Core     Hex PublicKey ‚úì ‚úì ‚úì   WIF PrivateKey ‚úì ‚úó ‚úì   Extended Keys (xpub/xprv) ‚úì ‚úó ‚úì     Script Types (top level)    Script Type BDK rust-miniscript Bitcoin Core     pk() ‚úì ‚úì ‚úì   pkh() ‚úì ‚úì ‚úì   wpkh() ‚úì ‚úì ‚úì   sh(wpkh()) ‚úì ‚úì ‚úì   sh() ‚úì ‚úì ‚úì   wsh() ‚úì ‚úì ‚úì   sh(wsh()) ‚úì ‚úì ‚úì   combo() ‚úó ‚úó ‚úì   addr() ‚úó ‚úó ‚úì   raw() ‚úó ‚úó ‚úì   Bare scripts ‚úì ‚úì ‚úó     Operators    Operator BDK rust-miniscript Bitcoin Core     pk() ‚úì ‚úì ‚úì   pk_h() ‚úì ‚úì ‚úì - as pkh()   older() ‚úì ‚úì ‚úó   after() ‚úì ‚úì ‚úó   sha256() ‚úì ‚úì ‚úó   hash256() ‚úì ‚úì ‚úó   ripemd160() ‚úì ‚úì ‚úó   hash160() ‚úì ‚úì ‚úó   andor() ‚úì ‚úì ‚úó   and_{v,b,n}() ‚úì ‚úì ‚úó   or_{b,c,d,i}() ‚úì ‚úì ‚úó   multi() ‚úì ‚úì ‚úì   thresh() ‚úì ‚úì ‚úó   sortedmulti() ‚úó ‚úó ‚úì     Modifiers    Script Type BDK rust-miniscript Bitcoin Core     a: ‚úì ‚úì ‚úó   s: ‚úì ‚úì ‚úó   c: ‚úì ‚úì ‚úó   t: ‚úì ‚úì ‚úó   d: ‚úì ‚úì ‚úó   v: ‚úì ‚úì ‚úó   j: ‚úì ‚úì ‚úó   n: ‚úì ‚úì ‚úó   l: ‚úì ‚úì ‚úó   u: ‚úì ‚úì ‚úó     For a more thorough description of these operators and modifiers see Sipa\u0026rsquo;s Miniscript Page and Bitcoin Core\u0026rsquo;s.\nExamples Some examples of valid BDK descriptors are:\n   Spending Policy Descriptor Address 0 Address 1     Static P2PKH pkh(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR) mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr   Static P2PKH, watch-only pkh(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c) mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr   P2WSH 2-of-2 with one private key wsh(multi(2,tprv8ZgxMBicQKsPePmENhT9N9yiSfTtDoC1f39P7nNmgEyCB6Nm4Qiv1muq4CykB9jtnQg2VitBrWh8PJU8LHzoGMHTrS2VKBSgAz7Ssjf9S3P/0/*,tpubDBYDcH8P2PedrEN3HxWYJJJMZEdgnrqMsjeKpPNzwe7jmGwk5M3HRdSf5vudAXwrJPfUsfvUPFooKWmz79Lh111U51RNotagXiGNeJe3i6t/1/*)) tb1qqsat6c82fvdy73rfzye8f7nwxcz3xny7t56azl73g95mt3tmzvgs9a8vjs tb1q7sgx6gscgtau57jduend6a8l445ahpk3dt3u5zu58rx5qm27lhkqgfdjdr   P2WSH-P2SH one key + 10 days timelock sh(wsh(and_v(vc:pk_h(tprv8ZgxMBicQKsPePmENhT9N9yiSfTtDoC1f39P7nNmgEyCB6Nm4Qiv1muq4CykB9jtnQg2VitBrWh8PJU8LHzoGMHTrS2VKBSgAz7Ssjf9S3P/0/*),older(1440)))) 2Mtk2nyS98MCi2P7TkoBGLaJviBy956XxB1 2MuEStKzYhqb5HCFgHz9153tZsL5sVqV5xC     Implementation Details BDK extends the capabilities of rust-miniscript by introducing the concept of an ExtendedDescriptor: it represents a descriptor that contains one or more \u0026ldquo;derivable keys\u0026rdquo; like xpubs or xprvs and can be \u0026ldquo;derived\u0026rdquo; to a normal Descriptor by deriving every single one of its keys. It is currently called \u0026ldquo;StringDescriptor\u0026rdquo; in the code, because it\u0026rsquo;s implemented as a wrapped miniscript::Descriptor\u0026lt;String\u0026gt;.\nExtendedDescriptors are derived using a single index instead of a full derivation path: this is because normally most of the path is fixed and can be represented right after the xpub/xprv itself, and only the final index changes for each address. This is what\u0026rsquo;s normally called a DescriptorExtendedKey in codebase, and it\u0026rsquo;s the represented with a similar syntax to Bitcoin Core\u0026rsquo;s, such as:\n[d34db33f/44'/0'/0']xpub6ERApfZwUNrhL.......rBGRjaDMzQLcgJvLJuZZvRcEL/0/* "
},
{
	"uri": "https://test.bitcoindevkit.org/repl/playground/",
	"title": "Playground",
	"tags": [],
	"description": "",
	"content": " .error { color: orange; }   Policy Compiler     P2SH P2WSH P2SH-P2WSH    Map every alias to an existing key or generate a new one. You can also specify known keys directly in the visual editor or the policy input field.       Wallet    Descriptor   Change Descriptor (optional)          This page contains webassembly and javascript content, please enable javascript in your browser.   let compilerKeyAliasIndex = 0; function htmlToElement(html) { var template = document.createElement('template'); html = html.trim(); template.innerHTML = html; return template.content.firstChild; } function addCompilerKeyAlias(e) { if (e) { e.preventDefault(); } const newIndex = ++compilerKeyAliasIndex; const html = ` Generate WIF Key Generate Extended Key Existing Key   `; const prevAddBtn = document.getElementById('add_key_alias'); if (prevAddBtn) { prevAddBtn.remove(); } document.getElementById('compiler_aliases').appendChild(htmlToElement(html)); } function updateCompilerFormAlias(e) { const extraInput = Array.from(document.getElementsByName('extra')).filter((x) = x.attributes[\"data-index\"].value == e.attributes[\"data-index\"].value)[0]; switch (e.value) { case 'gen_wif': extraInput.style.display = 'none'; break; case 'gen_ext': extraInput.style.display = 'inherit'; extraInput.placeholder = \"Derivation Path (optional). Example: /44'/0'/0'/0/*\"; break; case 'existing': extraInput.style.display = 'inherit'; extraInput.placeholder = \"WIF, tpub or hex public key. Example: 02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c\"; break; } } (() = { addCompilerKeyAlias(); })();  "
},
{
	"uri": "https://test.bitcoindevkit.org/supporters/",
	"title": "Supporters",
	"tags": [],
	"description": "",
	"content": "The Bitcoin Dev Kit project is proudly supported by:\nBitfinex   Square Crypto    "
},
{
	"uri": "https://test.bitcoindevkit.org/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "Bitcoin Dev Kit The Bitcoin Dev Kit (BDK) project (originally called Magical Bitcoin üßô) aims to build a collection of tools and libraries that are designed to be a solid foundation for cross platform Bitcoin wallets, along with a fully working reference implementation wallet called Magical Bitcoin. All BDK components are designed to be lightweight and modular so that they can be adapted for virtually any use-case: from single-sig mobile wallets to multi-billion-dollar cold storage vaults.\nThe main long-term goal is to concentrate the development efforts of multiple people and companies into one open source and very well reviewed project, instead of dispersing them over multiple closed/semi-closed or poorly designed projects.\nKeep in mind that this project is still in a very early phase of development. The APIs and the general architecture shouldn\u0026rsquo;t be considered stable yet. At the moment most of the code is concentrated in the main repo and is slowly being refactored and taken out into separate, independent modules.\n Playground As a way of demonstrating the flexibly of this project, a minimalistic command line tool (also called \u0026ldquo;repl\u0026rdquo;) is available as a debugging tool in the main bdk repo. It has been compiled to WebAssembly and can be used directly from the browser. See the playground section to give it a try!\nThe playground relies on Esplora to monitor the blockchain and is currently locked in testnet-only mode, for obvious safety reasons. The native command line tool can also be used in regtest mode when installed on a computer. See the REPL section to learn more.\nDescriptors One of the original milestones of this project was to provide wallets with \u0026ldquo;almost magically\u0026rdquo; support for very complex spending policies, without having to individually translate them into code. It may sound disappointing, but there isn\u0026rsquo;t, in fact, any real magic in this wallet: the generalization is achieved thanks to descriptors, that are now slowly starting to see adoption in a few other Bitcoin projects as well.\nThe author of this project strongly believes descriptors will be a big part of the future generation of Bitcoin wallets, since they provide a very flexible scripting language that can also be extended as the technology and tooling of Bitcoin evolves and changes (Schnorr signatures, Taproot, etc).\nTo learn more, check out the specific Descriptors section.\n"
},
{
	"uri": "https://test.bitcoindevkit.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://test.bitcoindevkit.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]