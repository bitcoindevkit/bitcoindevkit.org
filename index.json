[
{
	"uri": "https://bitcoindevkit.org/blog/",
	"title": "Blog",
	"tags": [],
	"description": "",
	"content": "This blog is used to publish announcements, guides and more regarding the BDK project. Anybody can contribute by sending a pull request to our GitHub repository.\n"
},
{
	"uri": "https://bitcoindevkit.org/repl/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Requirements The only requirement is a Linux/macOS system with a fairly recent Rust toolchain installed. Since Linux distros tend to lag behind with updates, the quickest way to install the Rust compiler and Cargo is rustup.rs. You can head there and follow their instructions, after which you can test if everything went fine by running cargo version, which should print something like:\ncargo 1.45.0 (744bd1fbb 2020-06-15) At the time of writing, the project requires cargo \u0026gt;= 1.45.0, which is the latest stable as of June 2020. If you have an older version installed with rustup.rs, you can upgrade it with rustup update.\nIf you really don\u0026rsquo;t want to pipe the output of curl into sh, you can also try using a Docker image and working inside of it, but that\u0026rsquo;s meant for more advanced users and won\u0026rsquo;t be covered in this guide.\nInstalling BDK repl Once Cargo is installed, you can proceed to install the interactive BDK repl tool directly from the GitHub repository, by running:\ncargo install --git https://github.com/bitcoindevkit/bdk --features=cli-utils,esplora --example repl This command will probably take a while to finish, since it will fetch and compile all the dependencies and the bdk library itself. Once it\u0026rsquo;s done, you can check if everything went fine by running repl --help which should print something like this:\nMagical Bitcoin Wallet 0.1.0 Riccardo Casatta \u0026lt;riccardo@casatta.it\u0026gt;:Alekos Filini \u0026lt;alekos.filini@gmail.com\u0026gt; A modern, lightweight, descriptor-based wallet USAGE: repl [FLAGS] [OPTIONS] --descriptor \u0026lt;DESCRIPTOR\u0026gt; [SUBCOMMAND] FLAGS: -h, --help Prints help information -v Sets the level of verbosity -V, --version Prints version information OPTIONS: -c, --change_descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for internal addresses -d, --descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for the external addresses -n, --network \u0026lt;NETWORK\u0026gt; Sets the network [default: testnet] [possible values: testnet, regtest] -s, --server \u0026lt;SERVER:PORT\u0026gt; Sets the Electrum server to use [default: tn.not.fyi:55001] -w, --wallet \u0026lt;WALLET_NAME\u0026gt; Selects the wallet to use [default: main] SUBCOMMANDS: broadcast Extracts the finalized transaction from a PSBT and broadcasts it to the network create_tx Creates a new unsigned tranasaction get_balance Returns the current wallet balance get_new_address Generates a new external address help Prints this message or the help of the given subcommand(s) list_unspent Lists the available spendable UTXOs policies Returns the available spending policies for the descriptor repl Opens an interactive shell sign Signs and tries to finalize a PSBT sync Syncs with the chosen Electrum server An example command to sync a testnet wallet looks like this:\nrepl --descriptor \u0026quot;wpkh(tprv8ZgxMBicQKsPexGYyaFwnAsCXCjmz2FaTm6LtesyyihjbQE3gRMfXqQBXKM43DvC1UgRVv1qom1qFxNMSqVAs88qx9PhgFnfGVUdiiDf6j4/0/*)\u0026quot; --network testnet --server tcp://testnet.aranguren.org:51001 sync "
},
{
	"uri": "https://bitcoindevkit.org/repl/concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "Now, in order to better grasp some of the design choices made by BDK, it\u0026rsquo;s important to understand the main concept driving the development of this project, and the goal that it\u0026rsquo;s trying to achieve.\nBDK is aiming first of all to be a set of libraries and tools, all meant to be very reusable and adaptable. Developers working on their own wallets or other projects that are trying to integrate Bitcoin can pick the tools they need and piece them together to prototype and quickly ship a working product. This means that the REPL that we\u0026rsquo;ve just installed is designed to be a very thin layer over the APIs exposed by the various components of the library, not a full, end-user-ready Bitcoin wallet.\nThis concept leads to a few design choices that are arguably very bad for the \u0026ldquo;UX\u0026rdquo; of this wallet, but that allow developers to work more directly with the underlying library. For instance:\n BDK has an internal database that\u0026rsquo;s used to store data about received transactions, spendable UTXOs, etc. This database is stored by default in your home folder, in ~/.bdk-bitcoin. The database will never contain any data that can\u0026rsquo;t be recreated purely by looking at the blockchain. Keys, descriptors, Electrum endpoints are not stored in there. This explains why you\u0026rsquo;ll have to specify them every time in the command line. It can be seen more like a cache and can be safely deleted without risking funds. BDK doesn\u0026rsquo;t automatically \u0026ldquo;monitor\u0026rdquo; the blockchain, instead there\u0026rsquo;s a sync command that has to be called by the user. When you create a transaction and then sign it, it\u0026rsquo;s not automatically broadcast to the network. There\u0026rsquo;s a broadcast command that does this. Moreover, the command doesn\u0026rsquo;t accept a normal Bitcoin raw transaction, but instead a PSBT. That\u0026rsquo;s because internally transactions are always moved as PSBTs, and again, the broadcast command is just a very thin wrapper over the raw library call.  There are probably more of these examples, but hopefully by this point you\u0026rsquo;ll have more or less understood the gist of it. If you are not a developer, some parts of this will feel weird, inefficient, hard to understand, and that\u0026rsquo;s absolutely normal. Just try to survive through the pain and you\u0026rsquo;ll be rewarded!\n"
},
{
	"uri": "https://bitcoindevkit.org/repl/interface/",
	"title": "Interface",
	"tags": [],
	"description": "",
	"content": "Remember the repl --help command you ran before? Let\u0026rsquo;s analyze its output here to figure out the interface:\nFlags FLAGS: -h, --help Prints help information -v Sets the level of verbosity -V, --version Prints version information These are the optional flags that can be set with every command. The -h flag prints the help message, the -V flag only prints the version and the -v is actually ignored at the moment.\nVerbosity If you want to increase the verbosity of the output, you should use the RUST_LOG environment variable. You can set it like so to see a lot more of what\u0026rsquo;s going on behind the scenes, before running the repl command. You only have to do this once when you open a new shell, after that you can run the repl command multiple times.\nexport RUST_LOG=\u0026#34;bdk=debug\u0026#34; Options OPTIONS: -c, --change_descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for internal addresses -d, --descriptor \u0026lt;DESCRIPTOR\u0026gt; Sets the descriptor to use for the external addresses -e, --esplora \u0026lt;ESPLORA\u0026gt; Use the esplora server if given as parameter -n, --network \u0026lt;NETWORK\u0026gt; Sets the network [default: testnet] [possible values: testnet, regtest] -s, --server \u0026lt;SERVER:PORT\u0026gt; Sets the Electrum server to use [default: ssl://electrum.blockstream.info:60002] -w, --wallet \u0026lt;WALLET_NAME\u0026gt; Selects the wallet to use [default: main] -p, --proxy \u0026lt;SERVER:PORT\u0026gt; Sets the SOCKS5 proxy for the Electrum client These are the global options that can be set. They are pretty much like the flags, but they also take a value. The only required one is the --descriptor or -d flag, since every wallet must have an associated descriptor.\nThe --change-descriptor flag can be used to set a different descriptor for the change addresses, sometimes called \u0026ldquo;internal\u0026rdquo; addresses in Bitcoin Core. Unfortunately there isn\u0026rsquo;t really consensus on a nice way to encode information about the change derivation inside the standard descriptor, so we are stuck with having two separate ones. Keep in mind though, that even if you don\u0026rsquo;t specify a change descriptor, you\u0026rsquo;ll still be able to create transactions - the change address will simply be generated from the standard descriptor.\nThe --network flag can be used to change the network. Right now only testnet and regtest are supported since the code is very much not production-ready yet.\nThe --server flag can be used to select the Electrum server to use. By default it\u0026rsquo;s connecting to Blockstream\u0026rsquo;s electrum servers, which seems pretty stable. If you are having connection issues, you can also try with one of the other servers listed here and see if you have more luck with those. Right now both plaintext and ssl servers are supported (prefix tcp:// or no prefix at all for tcp, prefix ssl:// for ssl).\nThe --esplora flag can be used to connect to an Esplora instance instead of using Electrum. It should be set to the API\u0026rsquo;s \u0026ldquo;base url\u0026rdquo;. For public instances of Esplora this is https://blockstream.info/api for mainnet and https://blockstream.info/testnet/api for testnet.\nThe --proxy flag can be optionally used to specify a SOCKS5 proxy to use when connecting to the Electrum server. Spawning a local Tor daemon and using it as a proxy will allow you to connect to .onion Electrum URLs. Keep in mind that only plaintext server are supported over a proxy\nThe --wallet flag can be used to select which wallet to use, if you have more than one of them. If you get a ChecksumMismatch error when you make some changes to your descriptor, it\u0026rsquo;s because it does not match anymore the one you\u0026rsquo;ve used to initialize the cache. One solution could be to switch to a new wallet name, or delete the cache directory at ~/.bdk and start from scratch.\nSubcommands    Command Description     broadcast Broadcasts a transaction to the network. Takes either a raw transaction or a PSBT to extract   bump_fee Bumps the fees of an RBF transaction   combine_psbt Combines multiple PSBTs into one   create_tx Creates a new unsigned tranasaction   extract_psbt Extracts a raw transaction from a PSBT   finalize_psbt Finalizes a psbt   get_balance Returns the current wallet balance   get_new_address Generates a new external address   list_transactions Lists all the incoming and outgoing transactions of the wallet   list_unspent Lists the available spendable UTXOs   policies Returns the available spending policies for the descriptor   public_descriptor Returns the public version of the wallet\u0026rsquo;s descriptor(s)   repl Opens an interactive shell   sign Signs and tries to finalize a PSBT   sync Syncs with the chosen Electrum server    These are the main \u0026ldquo;functions\u0026rdquo; of the wallet. Most of them are pretty self explanatory, but we\u0026rsquo;ll go over them quickly anyways. You can get more details about every single command by running repl \u0026lt;subcommand\u0026gt; --help.\nbroadcast OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to extract and broadcast --tx \u0026lt;RAWTX\u0026gt; Sets the raw transaction to broadcast Broadcasts a transaction. The transaction can be a raw hex transaction or a PSBT, in which case it also has to be \u0026ldquo;finalizable\u0026rdquo; (i.e. it should contain enough partial signatures to construct a finalized valid scriptsig/witness).\nbump_fee FLAGS: -a, --send_all Allows the wallet to reduce the amount of the only output in order to increase fees. This is generally the expected behavior for transactions originally created with `send_all` OPTIONS: -f, --fee_rate \u0026lt;SATS_VBYTE\u0026gt; The new targeted fee rate in sat/vbyte -t, --txid \u0026lt;txid\u0026gt; TXID of the transaction to update --unspendable \u0026lt;TXID:VOUT\u0026gt;... Marks an utxo as unspendable, in case more inputs are needed to cover the extra fees --utxos \u0026lt;TXID:VOUT\u0026gt;... Selects which utxos *must* be added to the tx. Unconfirmed utxos cannot be used Bumps the fee of a transaction made with RBF. The transaction to bump is specified using the --txid flag and the new fee rate with --fee_rate.\nThe --send_all flag should be enabled if the original transaction was also made with --send_all.\ncombine_psbt OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt;... Add one PSBT to comine. This option can be repeated multiple times, one for each PSBT Combines multiple PSBTs by merging metadata and partial signatures. It can be used to merge multiple signed PSBTs into a single PSBT that contains every signature and is ready to be finalized.\ncreate_tx FLAGS: -a, --send_all Sends all the funds (or all the selected utxos). Requires only one addressees of value 0 -r, --enable_rbf Enables Replace-By-Fee (BIP125) OPTIONS: --external_policy \u0026lt;POLICY\u0026gt; Selects which policy should be used to satisfy the external descriptor -f, --fee_rate \u0026lt;SATS_VBYTE\u0026gt; Fee rate to use in sat/vbyte --internal_policy \u0026lt;POLICY\u0026gt; Selects which policy should be used to satisfy the internal descriptor --to \u0026lt;ADDRESS:SAT\u0026gt;... Adds an addressee to the transaction --unspendable \u0026lt;TXID:VOUT\u0026gt;... Marks an utxo as unspendable --utxos \u0026lt;TXID:VOUT\u0026gt;... Selects which utxos *must* be spent Creates a new unsigned PSBT. The flags allow to set a custom fee rate (the default is 1.0 sat/vbyte) with --fee_rate or -f, the list of UTXOs that should be considered unspendable with --unspendable (this option can be specified multiple times) and a list of UTXOs that must be spent with --utxos (again, this option can also be specified multiple times).\nThe --to option sets the receiver address of the transaction, and should contain the address and amount in Satoshi separated by a colon, like: --to --to 2NErbQPsooXRatRJdrXDm9wKR2fRiZDT9wL:50000. This option can also be specified multiple times to send to multiple addresses at once.\nThe --send_all flag can be used to send the value of all the spendable UTXOs to a single address, without creating a change output. If this flag is set, there must be only one --to address, and its value will be ignored (it can be set to 0).\nThe --external_policy and --internal_policy options are two advanced flags that can be used to select the spending policy that the sender intends to satisfy in this transaction. They are normally not required if there\u0026rsquo;s no ambiguity, but sometimes with complex descriptor one or both of them have to be specified, or you\u0026rsquo;ll get a SpendingPolicyRequired error. Those flags should be set to a JSON object that maps a policy node id to the list of child indexes that the user intends to satisfy for that node. This is probably better explained with an example:\nLet\u0026rsquo;s assume our descriptor is: sh(thresh(2,pk(A),sj:and_v(v:pk(B),n:older(6)),snj:and_v(v:pk(C),after(630000)))). There are three conditions and we need to satisfy two of them to be able to spend. The conditions are:\n Sign with the key corresponding to pk(A) Sign with the key corresponding to pk(B) AND wait 6 blocks Sign with the key corresponding to pk(C) AND wait that block 630,000 is reached  So if we write down all the possible outcomes when we combine them, we get:\n Sign with pk(A) + pk(B) + wait 6 blocks Sign with pk(A) + pk(C) + wait block 630,000 Sign with pk(B) + pk(C) + wait 6 blocks + wait block 630,000  In other words:\n If we choose option #1, the final transaction will need to have the nSequence of its inputs set to a value greather than or equal to 6, but the nLockTime can stay at 0. If we choose option #2, the final transaction will need to have its nLockTime set to a value greater than or equal to 630,000, but the nSequence can be set to a final value. If we choose option #3, both the nSequence and nLockTime must be set.  The wallet can\u0026rsquo;t choose by itself which one of these combination to use, so the user has to provide this information with the --external_policy flag.\nNow, let\u0026rsquo;s draw the condition tree to understand better how the chosen policy is represented: every node has its id shown right next to its name, like qd3um656 for the root node. These ids can be seen by running the policies command. Some ids have been omitted since they are not particularly relevant, in this example we will actually only use the root id.\ngraph TD; subgraph \" \" R[\"Root - qd3um656\"] -- A[\"pk(A) - ykfuwzkl\"] R[\"Root - qd3um656\"] -- B[\"B - ms3xjley\"] B[\"B - ms3xjley\"] -- B_0[\"pk(B)\"] B[\"B - ms3xjley\"] -- B_1[\"older(6)\"] end C[\"C - d8jph6ax\"] -- C_0[\"pk(C)\"] C[\"C - d8jph6ax\"] -- C_1[\"after(630,000)\"] R[\"Root - qd3um656\"] -- C[\"C - d8jph6ax\"]  Let\u0026rsquo;s imagine that we are walking down from the root, and we want to use option #1. So we will have to select pk(A) + the whole B node. Since these nodes have an id, we can use it to refer to them and say which children we want to use. In this case we want to use children #0 and #1 of the root, so our final policy will be: --external_policy {\u0026quot;qd3um656\u0026quot;:[0,1]}.\nextract_psbt OPTIONS: --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to extract Extracts the global transaction from a PSBT. Note that partial signatures are ignored in this step. If you want to merge the partial signatures back into the global transaction first, please use finalize_psbt first\nfinalize_psbt OPTIONS: --assume_height \u0026lt;HEIGHT\u0026gt; Assume the blockchain has reached a specific height --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to finalize Tries to finalize a PSBT by merging all the partial signatures and other elements back into the global transaction. This command fails if there are timelocks that have not yet expired, but the check can be overridden by specifying --assume_height to make the wallet assume that a future height has already been reached.\nget_balance This subcommand has no extra flags, and simply returns the available balance in Satoshis. This command should normally be called after sync, since it only looks into the local cache to determine the list of UTXOs.\nget_new_address This subcommand has no extra flags and returns a new address. It internally increments the derivation index and saves it in the database.\nlist_transactions This subcommand has no extra flags and returns the history of transactions made or received by the wallet, with their txid, confirmation height and the amounts (in Satoshi) \u0026ldquo;sent\u0026rdquo; (meaning, the sum of the wallet\u0026rsquo;s inputs spent in the transaction) and \u0026ldquo;received\u0026rdquo; (meaning, the sum of the outputs received by the wallet). Just like get_balance it should normally be called after sync, since it only operates on the internal cache.\nlist_unspent This subcommand has no extra flags and returns the list of available UTXOs and their value in Satoshi. Just like get_balance it should normally be called after sync, since it only operates on the internal cache.\npolicies This subcommand has no extra flags and returns the spending policies encoded by the descriptor in a more human-readable format. As an example, running the policies command on the descriptor shown earlier for the in the explanation of the create_tx command, it will return this:\n This is a tree-like recursive structure, so it tends to get huge as more and more pieces are added, but it\u0026rsquo;s in fact fairly simple. Let\u0026rsquo;s analyze a simple node of the tree:\n{ \u0026#34;id\u0026#34;:\u0026#34;qd3um656\u0026#34;, \u0026#34;type\u0026#34;:\u0026#34;SIGNATURE\u0026#34;, \u0026#34;pubkey\u0026#34;:\u0026#34;...\u0026#34;, \u0026#34;satisfaction\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;NONE\u0026#34; }, \u0026#34;contribution\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;COMPLETE\u0026#34;, \u0026#34;condition\u0026#34;:{} } }   id is a unique identifier to this specific node in the tree.\n  type, as the name implies, represents the type of node. It defines what should be provided to satisfy that particular node. Generally some other data are provided to give meaning to the type itself (like the pubkey field here in the example). There are basically two families of types: some of them can only be used as leaves, while some other can only be used as intermediate nodes.\nPossible leaf nodes are:\n SIGNATURE, requires a signature made with the specified key. Has a pubkey if it\u0026rsquo;s a single key, a fingerprint if the key is an xpub, or a pubkey_hash if the full public key is not present in the descriptor. SIGNATUREKEY, requires a signature plus the raw public key. Again, it can have a pubkey, fingerprint or pubkey_hash. SHA256PREIMAGE, requires the preimage of a given hash. HASH256PREIMAGE, requires the preimage of a given hash. RIPEMD160PREIMAGE, requires the preimage of a given hash. HASH160PREIMAGE, requires the preimage of a given hash. ABSOLUTETIMELOCK, doesn\u0026rsquo;t technically require anything to be satisfied, just waiting for the timelock to expire. Has a value field with the raw value of the timelock (can be both in blocks or time-based). RELATIVETIMELOCK, again only requires waiting for the timelock to expire. Has a value like ABSOLUTETIMELOCK.  Possible non-leaf nodes are:\n THRESH, defines a threshold of policies that has to be met to satisfy the node. Has an items field, which is a list of policies to satisfy and a threshold field that defines the threshold. MULTISIG, Similar to THRESH, has a keys field, which is a list of keys represented again as either pubkey, fingerprint or pubkey_hash and a threshold field.    satisfaction is currently not implemented and will be used to provide PSBT introspection, like understanding whether or not a node is already satisfied and to which extent in a PSBT.\n  contribution represents if so and how much, the provided descriptor can contribute to the node.\nThe possible types are:\n NONE, which means that the descriptor cannot contribute. COMPLETE, which means that the descriptor by itself is enough to completely satisfy the node. It also adds a condition field which represent any potential extra condition that has to be met to consider the node complete. An example are the timelock nodes, that are always complete but they have an extra csv or timelock condition. PARTIAL, which means that the descriptor can partially satisfy the descriptor. This adds a m, n, items that respectively represent the threshold, the number of available items to satisfy and the items that the provided descriptor can satisfy. Also adds a conditions field which is an integer to list of conditions map. The key is the child index and the map are all the possibile extra conditions that have to be satisfied if that node is used in the threshold. For instance, if you have a threshold of a SIGNATURE and a RELATIVETIMELOCK, in this order, the conditions field will be 1 ‚áí csv(x), because the item at index 1 needs the extra csv condition. PARTIALCOMPLETE, which is basically a PARTIAL with the size of items \u0026gt;= m. It\u0026rsquo;s treated as a separate entity to make the code a bit more clean and easier to implement. Like PARTIAL, it also has a m, n, items fields but the conditions field is a bit different: it\u0026rsquo;s a list of integers to list of conditions map. The key represents the combination that can be used to satisfy the threshold, and the value contains all the possible conditions that also have to be satisfied. For instance, if you have a 2-of-2 threshold of a TIMELOCK and a RELATIVETIMELOCK, the conditions field will be [0, 1] ‚áí csv(x) + timelock(y), because if the combination of items 0 and 1 is picked, both of their conditions will have to be meet too.    While the structure contains all of the intermediate nodes too, the root node is the most important one because defines how the descriptor can contribute to spend outputs sent to its addresses.\nFor instance, looking at the root node of the previous example (with the internal items omitted) from a descriptor that has all the three private keys for keys A, B and C, we can clearly see that it can satisfy the descriptor (type = PARTIALCOMPLETE) and the three options are [0, 1] ‚áí csv(6) (Option #1), [0, 2] ‚áí timelock(630,000) (Option #2) or [1, 2] ‚áí csv(6) + timelock(630,000) (Option #3).\n{ \u0026#34;type\u0026#34;:\u0026#34;THRESH\u0026#34;, \u0026#34;items\u0026#34;:[], \u0026#34;threshold\u0026#34;:2, \u0026#34;satisfaction\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;NONE\u0026#34; }, \u0026#34;contribution\u0026#34;:{ \u0026#34;type\u0026#34;:\u0026#34;PARTIALCOMPLETE\u0026#34;, \u0026#34;n\u0026#34;:3, \u0026#34;m\u0026#34;:2, \u0026#34;items\u0026#34;:[ 0, 1, 2 ], \u0026#34;conditions\u0026#34;:{ \u0026#34;[0, 1]\u0026#34;:[ { \u0026#34;csv\u0026#34;:6 } ], \u0026#34;[0, 2]\u0026#34;:[ { \u0026#34;timelock\u0026#34;:630000 } ], \u0026#34;[1, 2]\u0026#34;:[ { \u0026#34;csv\u0026#34;:6, \u0026#34;timelock\u0026#34;:630000 } ] } } } public_descriptor This subcommand has no extra flags and returns the \u0026ldquo;public\u0026rdquo; version of the wallet\u0026rsquo;s descriptor(s). It can be used to bootstrap a watch-only instance for the wallet.\nrepl This subcommand has no extra flags and launches an interactive shell session.\nsign OPTIONS: --assume_height \u0026lt;HEIGHT\u0026gt; Assume the blockchain has reached a specific height. This affects the transaction finalization, if there are timelocks in the descriptor --psbt \u0026lt;BASE64_PSBT\u0026gt; Sets the PSBT to sign Adds to the PSBT all the signatures it can produce with the secrets embedded in the descriptor (xprv or WIF keys). Returns the signed PSBT and, if there are enough item to satisfy the script, also the extracted raw Bitcoin transaction.\nOptionally, the assume_height option can be specified to let the wallet assume the blockchain has reached a specific height. This affects the finalization of the PSBT which is done right at the end of the signing process: the wallet tries to satisfy the spending condition of each input using the partial signatures collected. In case timelocks are present the wallet needs to know whether or not they have expired. This flag is particularly useful for offline wallets.\nsync This subcommand has no extra flags. It connects to the chosen Electrum server and synchronizes the list of transactions received and available UTXOs.\n"
},
{
	"uri": "https://bitcoindevkit.org/repl/regtest/",
	"title": "Regtest",
	"tags": [],
	"description": "",
	"content": "Running the REPL in regtest requires having a local Electrum server set-up. There are two main implementations, electrs in Rust and ElectrumX in Python. Since the Rust toolchain is already required to use BDK, this page will focus mostly on the former.\nElectrs can be installed by running:\ncargo install --git https://github.com/romanz/electrs --bin electrs Just like before, this command will probably take a while to finish.\nOnce it\u0026rsquo;s done, assuming you have a regtest bitcoind running in background, you can launch a new terminal and run the following command to actually start electrs:\nelectrs -vv --timestamp --db-dir /tmp/electrs-db --electrum-rpc-addr=\u0026#34;127.0.0.1:50001\u0026#34; --network=regtest --cookie-file=$HOME/.bitcoin/regtest/.cookie on macOS you should change the cookie-file to $HOME/Library/Application Support/Bitcoin/regtest/.cookie.\nThis will start the Electrum server on port 50001. You can then add the -n regtest -s localhost:50001 the repl commands to switch to the local regtest.\nTroubleshooting Stuck with \u0026ldquo;wait until bitcoind is synced (i.e. initialblockdownload = false)\u0026rdquo; Just generate a few blocks with bitcoin-cli generatetoaddress 1 \u0026lt;address\u0026gt;\nBonus: Docker If you have already installed Docker on your machine, you can also use üç£ Nigiri CLI to spin-up a complete development environment in regtest that includes a bitcoin node, an electrs explorer and the esplora web-app to visualize blocks and transactions in the browser.\nInstall üç£ Nigiri\n$ curl https://getnigiri.vulpem.com | bash Start Docker daemon and run Nigiri box\n$ nigiri start This will start electrum RPC interface on port 51401, the REST interface on 3000 and the esplora UI on 5000 (You can visit with the browser and look for blocks, addresses and transactions)\nYou can then add the -n regtest -s localhost:51401 to the repl commands to switch to the local regtest.\n"
},
{
	"uri": "https://bitcoindevkit.org/repl/compiler/",
	"title": "Compiler",
	"tags": [],
	"description": "",
	"content": "Introduction If you want to play around with more complicated spending policies, you\u0026rsquo;ll start to find it harder and harder to manually create the descriptors. This is where the miniscript compiler comes in! The bdk library includes a very simple compiler that can produce a descriptor given a spending policy. The syntax used to encode the spending policy is very well described in this page, specifically in the \u0026ldquo;Policy to Miniscript compiler\u0026rdquo;. The compiler included in BDK does basically the same job, but produces descriptors for rust-miniscript that have some minor differences from the ones made by the C++ implementation used in that website.\nInstallation To install the miniscript compiler run the following command:\ncargo install --git https://github.com/bitcoindevkit/bdk --features=\u0026#34;compiler\u0026#34; --example miniscriptc Once the command is done, you should have a miniscriptc command available. You can check if that\u0026rsquo;s the case by running miniscriptc --help.\nUsage In this case the interface is very simple: it accepts two arguments called \u0026ldquo;POLICY\u0026rdquo; and \u0026ldquo;TYPE\u0026rdquo;, in this order. The first one, as the name implies, sets the spending policy to compile. The latter defines the type of address that should be used to encapsulate the produced script, like a P2SH, P2WSH, etc.\nOptionally, the --parsed_policy flag can be enabled and it will make the compiler print the JSON \u0026ldquo;human-readable\u0026rdquo; version of the spending policy, as described in the policies subcommand of the CLI.\nThe --network flag can be used to change the network encoding of the address shown.\nKeep in mind that since the compiler loads and interprets the descriptor, all the public keys specified in the policy must be valid public keys. This differs from the web tool linked above that also accepts placeholders too. As described in the previous sections of this guide, the keys can be either xpub/xprv with or without metadata and a derivation path, WIF keys or raw hex public keys.\n Example Let\u0026rsquo;s take this policy for example:\nminiscriptc --parsed_policy and(pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR),or(50@pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),older(1000)))) sh-wsh The compiler should print something like:\n[2020-04-29T10:42:05Z INFO miniscriptc] Compiling policy: and(pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR),or(50@pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),older(1000))) [2020-04-29T10:42:05Z INFO miniscriptc] ... Descriptor: sh(wsh(and_v(or_c(c:pk(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c),v:older(1000)),c:pk(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR)))) [2020-04-29T10:42:05Z INFO miniscriptc] ... First address: 2MsqrJuZewY3o3ADAy1Uhi5vsBqTANjH3Cf JSON policy:\n Troubleshooting Nothing is printed This might mean that you have a RUST_LOG variable set to a value that suppresses the compiler\u0026rsquo;s log. You can try adding miniscriptc=info to your RUST_LOG value and see if that works, or open a new clean shell.\n"
},
{
	"uri": "https://bitcoindevkit.org/repl/",
	"title": "REPL",
	"tags": [],
	"description": "",
	"content": "REPL The bdk repo has a very minimalistic interactive shell called repl that acts both as a reference implementation of a wallet and a tool to quickly experiment with descriptors and transactions.\n"
},
{
	"uri": "https://bitcoindevkit.org/descriptors/",
	"title": "Descriptors",
	"tags": [],
	"description": "",
	"content": "Descriptors are a compact and semi-standard way to easily encode, or \u0026ldquo;describe\u0026rdquo;, how scripts (and subsequently, addresses) of a wallet should be generated. They can be especially helpful when working with multisigs or even more complex scripts, where the structure of the script itself is not trivial. They are a big step forward in making wallets more portable across different tools and apps, because for the first time they create a common language to describe a full bitcoin script that developers can use and integrate in their software.\nThe ecosystem around descriptors is still very much in its early stage, but they are starting to see some adoption in Bitcoin Core and other projects. BDK aims to produce the first \u0026ldquo;Native Descriptor\u0026rdquo; Bitcoin library that can be used by developers to build their own \u0026ldquo;Native Descriptor Wallets\u0026rdquo;.\nCompatibility Matrix Below are some tables to highlight the differences between Bitcoin Core\u0026rsquo;s descriptor support, rust-miniscript\u0026rsquo;s one and BDK\u0026rsquo;s.\nKey Types    Key Type BDK rust-miniscript Bitcoin Core     Hex PublicKey ‚úì ‚úì ‚úì   WIF PrivateKey ‚úì ‚úó ‚úì   Extended Keys (xpub/xprv) ‚úì ‚úó ‚úì     Script Types (top level)    Script Type BDK rust-miniscript Bitcoin Core     pk() ‚úì ‚úì ‚úì   pkh() ‚úì ‚úì ‚úì   wpkh() ‚úì ‚úì ‚úì   sh(wpkh()) ‚úì ‚úì ‚úì   sh() ‚úì ‚úì ‚úì   wsh() ‚úì ‚úì ‚úì   sh(wsh()) ‚úì ‚úì ‚úì   combo() ‚úó ‚úó ‚úì   addr() ‚úó ‚úó ‚úì   raw() ‚úó ‚úó ‚úì   Bare scripts ‚úì ‚úì ‚úó     Operators    Operator BDK rust-miniscript Bitcoin Core     pk() ‚úì ‚úì ‚úì   pk_h() ‚úì ‚úì ‚úì - as pkh()   older() ‚úì ‚úì ‚úó   after() ‚úì ‚úì ‚úó   sha256() ‚úì ‚úì ‚úó   hash256() ‚úì ‚úì ‚úó   ripemd160() ‚úì ‚úì ‚úó   hash160() ‚úì ‚úì ‚úó   andor() ‚úì ‚úì ‚úó   and_{v,b,n}() ‚úì ‚úì ‚úó   or_{b,c,d,i}() ‚úì ‚úì ‚úó   multi() ‚úì ‚úì ‚úì   thresh() ‚úì ‚úì ‚úó   sortedmulti() ‚úì ‚úì ‚úì     Modifiers    Script Type BDK rust-miniscript Bitcoin Core     a: ‚úì ‚úì ‚úó   s: ‚úì ‚úì ‚úó   c: ‚úì ‚úì ‚úó   t: ‚úì ‚úì ‚úó   d: ‚úì ‚úì ‚úó   v: ‚úì ‚úì ‚úó   j: ‚úì ‚úì ‚úó   n: ‚úì ‚úì ‚úó   l: ‚úì ‚úì ‚úó   u: ‚úì ‚úì ‚úó     For a more thorough description of these operators and modifiers see Sipa\u0026rsquo;s Miniscript Page and Bitcoin Core\u0026rsquo;s.\nExamples Some examples of valid BDK descriptors are:\n   Spending Policy Descriptor Address 0 Address 1     Static P2PKH pkh(cSQPHDBwXGjVzWRqAHm6zfvQhaTuj1f2bFH58h55ghbjtFwvmeXR) mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr   Static P2PKH, watch-only pkh(02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c) mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr mrkwtj5xpYQjHeJe5wsweNjVeTKkvR5fCr   P2WSH 2-of-2 with one private key wsh(multi(2,tprv8ZgxMBicQKsPePmENhT9N9yiSfTtDoC1f39P7nNmgEyCB6Nm4Qiv1muq4CykB9jtnQg2VitBrWh8PJU8LHzoGMHTrS2VKBSgAz7Ssjf9S3P/0/*,tpubDBYDcH8P2PedrEN3HxWYJJJMZEdgnrqMsjeKpPNzwe7jmGwk5M3HRdSf5vudAXwrJPfUsfvUPFooKWmz79Lh111U51RNotagXiGNeJe3i6t/1/*)) tb1qqsat6c82fvdy73rfzye8f7nwxcz3xny7t56azl73g95mt3tmzvgs9a8vjs tb1q7sgx6gscgtau57jduend6a8l445ahpk3dt3u5zu58rx5qm27lhkqgfdjdr   P2WSH-P2SH one key + 10 days timelock sh(wsh(and_v(vc:pk_h(tprv8ZgxMBicQKsPePmENhT9N9yiSfTtDoC1f39P7nNmgEyCB6Nm4Qiv1muq4CykB9jtnQg2VitBrWh8PJU8LHzoGMHTrS2VKBSgAz7Ssjf9S3P/0/*),older(1440)))) 2Mtk2nyS98MCi2P7TkoBGLaJviBy956XxB1 2MuEStKzYhqb5HCFgHz9153tZsL5sVqV5xC     Implementation Details BDK extends the capabilities of rust-miniscript by introducing the concept of an ExtendedDescriptor: it represents a descriptor that contains one or more \u0026ldquo;derivable keys\u0026rdquo; like xpubs or xprvs and can be \u0026ldquo;derived\u0026rdquo; to a normal Descriptor by deriving every single one of its keys. It is currently called \u0026ldquo;StringDescriptor\u0026rdquo; in the code, because it\u0026rsquo;s implemented as a wrapped miniscript::Descriptor\u0026lt;String\u0026gt;.\nExtendedDescriptors are derived using a single index instead of a full derivation path: this is because normally most of the path is fixed and can be represented right after the xpub/xprv itself, and only the final index changes for each address. This is what\u0026rsquo;s normally called a DescriptorExtendedKey in codebase, and it\u0026rsquo;s the represented with a similar syntax to Bitcoin Core\u0026rsquo;s, such as:\n[d34db33f/44'/0'/0']xpub6ERApfZwUNrhL.......rBGRjaDMzQLcgJvLJuZZvRcEL/0/* "
},
{
	"uri": "https://bitcoindevkit.org/repl/playground/",
	"title": "Playground",
	"tags": [],
	"description": "",
	"content": " .error { color: orange; }   Policy Compiler     P2SH P2WSH P2SH-P2WSH    Map every alias to an existing key or generate a new one. You can also specify known keys directly in the visual editor or the policy input field.       Wallet    Descriptor   Change Descriptor (optional)          This page contains webassembly and javascript content, please enable javascript in your browser.   let compilerKeyAliasIndex = 0; function htmlToElement(html) { var template = document.createElement('template'); html = html.trim(); template.innerHTML = html; return template.content.firstChild; } function addCompilerKeyAlias(e) { if (e) { e.preventDefault(); } const newIndex = ++compilerKeyAliasIndex; const html = ` Generate WIF Key Generate Extended Key Existing Key   `; const prevAddBtn = document.getElementById('add_key_alias'); if (prevAddBtn) { prevAddBtn.remove(); } document.getElementById('compiler_aliases').appendChild(htmlToElement(html)); } function updateCompilerFormAlias(e) { const extraInput = Array.from(document.getElementsByName('extra')).filter((x) = x.attributes[\"data-index\"].value == e.attributes[\"data-index\"].value)[0]; switch (e.value) { case 'gen_wif': extraInput.style.display = 'none'; break; case 'gen_ext': extraInput.style.display = 'inherit'; extraInput.placeholder = \"Derivation Path (optional). Example: /44'/0'/0'/0/*\"; break; case 'existing': extraInput.style.display = 'inherit'; extraInput.placeholder = \"WIF, tpub or hex public key. Example: 02e96fe52ef0e22d2f131dd425ce1893073a3c6ad20e8cac36726393dfb4856a4c\"; break; } } (() = { addCompilerKeyAlias(); })();  "
},
{
	"uri": "https://bitcoindevkit.org/supporters/",
	"title": "Supporters",
	"tags": [],
	"description": "",
	"content": "The Bitcoin Dev Kit project is proudly supported by:\nBitfinex   Square Crypto    "
},
{
	"uri": "https://bitcoindevkit.org/blog/author/alekos-filini/",
	"title": "Alekos Filini",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/author/",
	"title": "Author",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/blog/tags/getting-started/",
	"title": "getting started",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/blog/2020/12/hello-world/",
	"title": "Hello World!",
	"tags": ["getting started", "rust"],
	"description": "Getting started using the BDK library in a very simple Rust project",
	"content": "Introduction This article should serve as a \u0026ldquo;getting started\u0026rdquo; guide for developers who are considering integrating BDK in their projects: it tries to introduce the reader to the basic concepts behind the library and some of its modules and components that can be used to build a very simple functioning Bitcoin wallet. All the information written in this article are valid for the current master git branch, and should remain valid for the upcoming v0.2.0 release which is planned to be tagged pretty soon.\nDesign Goals The main goal of the library is to be a solid foundation for Bitcoin wallets of any kind, on any platform: in practice, this means that the library should be:\n Very well-reviewed and tested Lightweight, so that it can be used easily on mobile devices as well Extendable, so that it can be adapted to perfectly suit different use-cases Generalized, meaning that it supports different types of Bitcoin scripts and wallets through the use of descriptors Reasonably easy to use, exposing a \u0026ldquo;high level\u0026rdquo; interface to the user and hiding all the complexity inside  These goals have a direct impact on the design of the internal components of the library, and as a consequence on the APIs that are exposed to the final user, which might in some cases feel counter-intuitive at first. Throughout the article, I will try to focus on those points and try to explain them as best as I can.\nThe Wallet Structure The Wallet structure is in many ways the heart of the library: it represents an instance of a wallet and exposes some APIs to perform all the typical operations one might want to do with a Bitcoin wallet, such as generating a new address, listing the transactions received, creating a transaction, etc.\nA Wallet instance can be constructed given at least one descriptor which would be used to derive both External and Internal addresses, or two if one prefers to keep them separated. External addresses are the ones returned by an explicit Wallet::get_new_address() call, while Internal addresses are generated internally to receive the change whenever a new transaction is created.\nA Wallet also needs at least one other component to function properly, its Database: it will be used as a cache to store the list of transactions synchronized with the blockchain, the UTXOs, the addresses generated, and a few other things. It\u0026rsquo;s important to note that the Database will never store any secret. Securely storing keys is explicitly left to the user of the library to implement, mainly because there isn\u0026rsquo;t really one good way to do it, that would work reliably on every platform. On mobile devices, for instance, the OS' keychain could be used, to allow unlocking the secrets with the use of biometric data (FaceID or fingerprint), while on desktop platform there isn\u0026rsquo;t generally a similar framework available and the user would have to implement something that meets their needs. It\u0026rsquo;s not excluded that in the future we could provide a \u0026ldquo;reference implementation\u0026rdquo; of secure multi-platform storage for keys, but that would very likely be released as a separate module outside of the Wallet structure, or potentially even as a separate library that could be reused for other applications as well.\nGoing back to our Wallet: given a descriptor and a Database we can build an \u0026ldquo;air-gapped\u0026rdquo;, or \u0026ldquo;Offline\u0026rdquo; wallet: basically, a wallet that physically can\u0026rsquo;t to connect to the Bitcoin network. It will still be able to generate addresses and sign PSBTs, but with a greatly reduced attack surface because a sizable part of the code that handles the logic to synchronize with the network would be entirely omitted in the final executable binary.\nThis is how an OfflineWallet can be created. Notice that we are using MemoryDatabase as our Database. We\u0026rsquo;ll get to that in a second.\nuse bdk::{Wallet, OfflineWallet}; use bdk::database::MemoryDatabase; use bdk::bitcoin::Network; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let external_descriptor = \u0026#34;wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84\u0026#39;/0\u0026#39;/0\u0026#39;/0/*)\u0026#34;; let internal_descriptor = \u0026#34;wpkh(tprv8ZgxMBicQKsPdy6LMhUtFHAgpocR8GC6QmwMSFpZs7h6Eziw3SpThFfczTDh5rW2krkqffa11UpX3XkeTTB2FvzZKWXqPY54Y6Rq4AQ5R8L/84\u0026#39;/0\u0026#39;/0\u0026#39;/1/*)\u0026#34;; let wallet: OfflineWallet\u0026lt;_\u0026gt; = Wallet::new_offline( external_descriptor, Some(internal_descriptor), Network::Testnet, MemoryDatabase::new(), )?; Ok(()) } Once we have our Wallet instance we can generate a new address and print it out:\n// ...  println!(\u0026#34;Generated Address: {}\u0026#34;, wallet.get_new_address()?); Building and running this code will print out:\nGenerated Address: tb1q7w0t936xp5p994qx506xj53gjdcmzjr2mkqghn Before we\u0026rsquo;ve talked about the benefits of an air-gapped wallet, but we should also talk about the disadvantages: the biggest one is the fact that it cannot create new transactions because it doesn\u0026rsquo;t know which UTXOs belong to the wallet. To get this information we generally need to sync with the network, but this wallet can\u0026rsquo;t physically do that.\nTo fix this we can add one more component to our Wallet: a Blockchain backend. In particular, we are going to use the ElectrumBlockchain which syncs with an Electrum server, since that\u0026rsquo;s available out of the box in BDK and is pretty fast.\nWe can change our Wallet construction to look something like this:\nuse bdk::blockchain::ElectrumBlockchain; use bdk::electrum_client::Client; // ...  let wallet = Wallet::new( external_descriptor, Some(internal_descriptor), Network::Testnet, MemoryDatabase::new(), ElectrumBlockchain::from(Client::new(\u0026#34;ssl://electrum.blockstream.info:60002\u0026#34;).unwrap()), )?; This piece of code is very similar to the one we wrote before, but this time we are using the Wallet::new() constructor instead of Wallet::new_offline(), and this takes an extra argument for the Blockchain type to use. Specifically here, we create an ElectrumBlockchain and connect to Blockstream\u0026rsquo;s public Electrum Testnet servers over SSL.\nNow, since we are running in the Testnet network, we can try to get some funds from a faucet online to this address we\u0026rsquo;ve generated. Once we have an incoming transaction we can do the first sync of our online wallet. this is again something that might seem counterintuitive at first: why do we have to manually ask the Wallet to sync itself? Can\u0026rsquo;t it do it periodically in background? The answer is that yes, that would definitely be possible, but it would remove some control on what\u0026rsquo;s happening inside the wallet from the user. This can be especially problematic on mobile platforms, where the OS tries very aggressively to suspend apps in background to save battery. Having a thread running and trying to make network requests while the app is in background would very likely cause errors or potentially crashes somewhere. So for this reason this operation has to be performed manually, to allow the user to call that function only at the right time.\nuse bdk::blockchain::noop_progress; // ...  wallet.sync(noop_progress(), None)?; In this case, we are not interested in receiving updates about the progress, and we just want to use the default settings, so we use noop_progress() and None as arguments. This will make queries to the Electrum server and store the list of transactions and UTXOs in our Database. In this case, we are using a MemoryDatabase, so those data are only going to be kept in RAM and dropped once our Wallet is dropped. This is very useful for playing around and experimenting, but not so great for real-world wallets: for that, you can use sled which is supported out of the box, or even use a custom database. More on that later!\nSo now that we\u0026rsquo;ve synced with the blockchain we can create our first transaction. First of all, we will print out the balance of our wallet to make sure that our wallet has seen the incoming transaction. Then we will create the actual transaction and we will specify some flags using the TxBuilder. To finish it off, we will ask the wallet to sign the transaction and then broadcast it to the network.\nRight now we will not get into details of all the available options in TxBuilder since that is definitely out of the scope of a \u0026ldquo;getting started\u0026rdquo; guide. For now, you can just imagine the builder as your way to tell the library how to build transactions. We\u0026rsquo;ll come back to this in a future article.\nuse std::str::FromStr; use bdk::bitcoin::Address; use bdk::TxBuilder; // ...  let balance = wallet.get_balance()?; println!(\u0026#34;Wallet balance in SAT: {}\u0026#34;, balance); let faucet_address = Address::from_str(\u0026#34;mkHS9ne12qx9pS9VojpwU5xtRd4T7X7ZUt\u0026#34;)?; let (unsigned_psbt, tx_details) = wallet.create_tx( TxBuilder::with_recipients(vec![(faucet_address.script_pubkey(), balance / 2)]) .enable_rbf(), )?; println!(\u0026#34;Transaction details: {:#?}\u0026#34;, tx_details); In this case, we are sending back half the balance to the faucet\u0026rsquo;s address and we are also enabling RBF since the default fees are at 1 satoshi/vbyte. With RBF we will be able to bump the fees of the transaction, should it get stuck in the mempool due to the low fee rate.\nAll that\u0026rsquo;s left to do once we have our unsigned PSBT is to sign it:\n// ...  let (signed_psbt, tx_finalized) = wallet.sign(unsigned_psbt, None)?; assert!(tx_finalized, \u0026#34;Tx has not been finalized\u0026#34;); And then broadcast it:\n// ...  let raw_transaction = signed_psbt.extract_tx(); let txid = wallet.broadcast(raw_transaction)?; println!( \u0026#34;Transaction sent! TXID: {txid}.\\nExplorer URL: https://blockstream.info/testnet/tx/{txid}\u0026#34;, txid = txid ); Custom Database and Blockchain types We briefly mentioned before that for our example we used the MemoryDatabase, but that it could also be swapped for a different one: this is one example of the modularity of BDK. By default, some database types are implemented in the library, namely (as of now) the MemoryDatabase which only keeps data in RAM and the sled database that can store data on a filesystem. But since the Database trait is public, users of the library can also implement different database types more suitable for their use-case.\nThe same is true for the Blockchain types: the library provides (through the use of opt-in features) implementations for the Electrum, Esplora and CompactFilters (Neutrino) backends. Those again can also be swapped with custom types if the user desires to do so.\nConclusion Hopefully, this article will help you get started with BDK! This is just a very quick and gentle introduction to the library, and only barely scratches the surface of what\u0026rsquo;s inside: we will keep publishing more articles in the future to explain some of the more advanced features of BDK, like key generation, using complex descriptors with multiple keys and/or timelocks, using external signers, etc.\nIf you\u0026rsquo;d like to learn more about the library feel free to ask any questions in the comment section down below, or join our Discord Community to chat with us directly!\n"
},
{
	"uri": "https://bitcoindevkit.org/blog/tags/rust/",
	"title": "rust",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/blog/tags/descriptor/",
	"title": "descriptor",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/blog/2020/11/descriptors-in-the-wild/",
	"title": "Descriptors in the wild",
	"tags": ["guide", "descriptor"],
	"description": "Guide to setup a 2-of-2 multisig using Bitcoin Core and BDK",
	"content": "I have tried to setup a 2 of 2 multi signature infrastructure with two different wallets, which know nothing about each other, but are compliant with two very important protocols: Output Descriptors and Partially Signed Bitcoin Transactions described in BIP 174.\nBefore these two protocols came into existence, making a multi signature setup and spending from it was possible only if the involved parties were using the same wallet (eg. Electrum Desktop Wallet). This limitation was due to the fact that the two parties had to agree:\n on the particular type of script and address to use on the way the transaction would be shared composed and signed with all the involved parties.  Output Descriptors are a way to express which kind scriptPubKey and addresses to produce with a key or a serie of keys.\nPSBT is instead the standard protocol used to create transaction and to enrich it with the necessary signatures and other components, to make it valid and complete.\nTogether they provide a common ground to create and use a multi signature infrastructure in a eterogeneous environment and this is what I have put to test.\nThe use case Imagine Alice and Bob owning a company and being willing to put the corporate cash in a 2of2 multi signature setup, so that each one of them have to agree and sign each transaction.\nThe role of Descriptors If Alice and Bob cannot agree on the software to use, to monitor the same financial situation, the two software must control and produce exactly the same series of multisignature addresses.\nTo make two different software produce the same addresses in a deterministic way we must ensure that they:\n produce the same pair of public keys combine them in the same order put them inside the same scriptPubKey to produce the same address  Here is where the Output Descriptors come into play. They describe:\n the sequence of public keys each extended key (xpub) will produce the sequence in which the new public keys of various parties will enter into the script the type of script the wallet will prepare with that group keys and so the type of address the group of keys will produce.  By sharing the same Descriptor, every compliant wallet will derive deterministically the same serie of multisig addresses.\nImmagine Alice using Bitcoin Core (from now on \u0026ldquo;Core\u0026rdquo;) as a Wallet and Bob using a \u0026ldquo;Last generation\u0026rdquo; wallet, Bitcoin Development Kit (from now on \u0026ldquo;BDK\u0026rdquo;), which uses descriptors and miniscript natively.\nEach of these two software wallet should be able to:\n Create a new address which is seen as belonging to the multi signature wallet in both software Express the consent of each party by partially sign the transaction in a way the other wallet can understand and complete it with its own signature.  The infrastructure of multiple Extended keys combined toghether to produce multiple multisignature addresses is often referred as Hierarchical Deterministic multi signature wallet or HDM.\nWhat follows are the steps to create the HDM usable both in Core and in BDK.\nNote: In Core, Descriptor wallets are still experimental and in general, both wallets should be tested for descriptor capabilities only in testnet.\nOur playground We will build a 2of2 key set up that will be used cooperatively by Bitcoin Core and Bitcoin Development Kit. The steps Alice and Bob will do are:\n creation of the seed and the derived Extended Master Public and send it to the other party Create the multi signature descriptor for each wallet Use each other\u0026rsquo;s software to receive testnet coins from a faucet return part of the coins to the faucet signing the transaction with both wallets.  We need:\n Bitcoin Dev Kit Bitcoin Core (at the present moment it is necessary to build one of the last commits on the main branch) Pycoin ku utility  1. Creating the seeds and the derived Extended Public keys Seeds and Extended Master Public We build an Extended Private Master Key for both wallet and derive a BIP84 Extended Master Public for Bitcoin Core and then for BDK.\nFor Bitcoin Core (Alice):\n# new Extended wallet data export core_key=$(ku -n XTN -j create) # New Extended Master Private export core_xprv=$(echo $core_key|jq -r '.wallet_key') # Derived Extended Pubblic key export core_xpub_84=$(ku -j -s 84H/0H/0H $core_xprv |jq -r '.public_version') export core_fingerprint=$(echo $core_key|jq -r '.fingerprint') # Now I build the xpubs (one for receiving and one for the change) # together with informations about the derivation path to be communicated # to BDK wallet's owner (Bob). export core_xpub_84_for_rec_desc=\u0026quot;[$core_fingerprint/84'/0'/0']$core_xpub_84/0/*\u0026quot; export core_xpub_84_for_chg_desc=\u0026quot;[$core_fingerprint/84'/0'/0']$core_xpub_84/1/*\u0026quot; For BDK (Bob) we do the same:\n# new Extended wallet data export BDK_key=$(ku -n XTN -j create) # New Extended Master Private export BDK_xprv=$(echo $BDK_key|jq -r '.wallet_key') # Derived Extended Pubblic key export BDK_xpub_84=$(ku -j -s 84H/0H/0H $BDK_xprv |jq -r '.public_version') export BDK_fingerprint=$(echo $BDK_key|jq -r '.fingerprint') # Now I build the derived xpubs to be communicated (to Alice). export BDK_xpub_84_for_rec_desc=\u0026quot;[$BDK_fingerprint/84'/0'/0']$BDK_xpub_84/0/*\u0026quot; export BDK_xpub_84_for_chg_desc=\u0026quot;[$BDK_fingerprint/84'/0'/0']$BDK_xpub_84/1/*\u0026quot; 2. Creation of the multi signature descriptor for each wallet To build a multisig wallet, each wallet owner must compose the descriptor adding:\n his derived extended private key AND all the extended public keys of the other wallets involved in the multi signature setup  The different nature of the two keys (one is private and one is public) is due to the fact that each wallet, to be able to partially sign the transaction, must manage the private key of the wallet\u0026rsquo;s owner AND have the other party\u0026rsquo;s public key. Otherwise if we put both public key, we would obtain a watch-only wallet unable to sign the transactions. If we had both extended private keys inside the descriptor, we would allow each party to finalize the transactions autonomously.\nIn Bitcoin Core: In our case, the multi signature descriptor for Bitcoin Core will be composed with:\n The BIP84 derived Extended Public Key from BDK The BIP84 derived Extended Private Key from Core.  BDK wallet\u0026rsquo;s owner will send to Core\u0026rsquo;s owner the derived xpub for this purpose. This is how the Core\u0026rsquo;s multisig descriptor will be created and put into an environment variable:\nexport core_rec_desc=\u0026quot;wsh(multi(2,$BDK_xpub_84_for_rec_desc,$core_xprv/84'/0'/0'/0/*))\u0026quot; Where of course $BDK_xpub_84_for_rec_descis the derived master public created in BDK and received by Core\u0026rsquo;s owner.\nThe meaning of what is before and after is illustrated in the doc that explain the use of Output Descriptors in Bitcoin Core.\nWe add the necessary checksum using the specific bitcoin-cli call.\nexport core_rec_desc_chksum=$core_rec_desc#$(bitcoin-cli -testnet getdescriptorinfo $core_rec_desc|jq -r '.checksum') We repeat the same to build the descriptor to receive the change.\nexport core_chg_desc=\u0026quot;wsh(multi(2,$BDK_xpub_84_for_chg_desc,$core_xprv/84'/0'/0'/1/*))\u0026quot; export core_chg_desc_chksum=$core_chg_desc#$(bitcoin-cli -testnet getdescriptorinfo $core_chg_desc|jq -r '.checksum') In BDK: For BDK we set the derivation for receiving addresses and change addresses in the command line (maybe setting an alias)\nBuilding the descriptor:\nexport BDK_rec_desc=\u0026quot;wsh(multi(2,$BDK_xprv/84'/0'/0'/0/*,$core_xpub_84_for_rec_desc))\u0026quot;` Please note that the order of the extended key in the descriptor MUST be the same in the 2 wallets.\nWe have chosen to put BDK first and in each software wallet, the public key derived from BDK will always come first. In alternative, we could have chosen to produce the descriptor, chosing a soretedmulti multisignature setup.\nexport BDK_rec_desc_chksum=$BDK_rec_desc#$(bitcoin-cli -testnet getdescriptorinfo $BDK_rec_desc|jq -r '.checksum') export BDK_chg_desc=\u0026quot;wsh(multi(2,$BDK_xprv/84'/0'/0'/1/*,$core_xpub_84_for_chg_desc))\u0026quot; export BDK_chg_desc_chksum=$BDK_chg_desc#$(bitcoin-cli -testnet getdescriptorinfo $BDK_chg_desc|jq -r '.checksum') To take a look at the variables we have produced so far:\nenv |grep 'core_' env |grep 'BDK_' Now we will use the multisig descriptor wallet to receive testnet coins with Alice and Bob\u0026rsquo;s software\n3. Use each other\u0026rsquo;s software to receive testnet coins from a faucet In Bitcoin Core Alice must create an empty, experimental new \u0026ldquo;descriptors wallet\u0026rdquo; in Core and to import the multisig Output Descriptor.\nbitcoin-cli -testnet createwallet \u0026quot;multisig2of2withBDK\u0026quot; false true \u0026quot;\u0026quot; false true false The flag are to:\n use the private keys make it empty no password provided to the wallet reusing of addresses not allowed \u0026ldquo;new experimental descriptors wallet\u0026rdquo; don\u0026rsquo;t load it on start up  bitcoin-cli -testnet -rpcwallet=multisig2of2withBDK importdescriptors \u0026quot;[{\\\u0026quot;desc\\\u0026quot;:\\\u0026quot;$core_rec_desc_chksum\\\u0026quot;,\\\u0026quot;timestamp\\\u0026quot;:\\\u0026quot;now\\\u0026quot;,\\\u0026quot;active\\\u0026quot;:true,\\\u0026quot;internal\\\u0026quot;:false},{\\\u0026quot;desc\\\u0026quot;:\\\u0026quot;$core_chg_desc_chksum\\\u0026quot;,\\\u0026quot;timestamp\\\u0026quot;:\\\u0026quot;now\\\u0026quot;,\\\u0026quot;active\\\u0026quot;:true,\\\u0026quot;internal\\\u0026quot;:true}]\u0026quot; Now Alice asks for her first receiving multisignature address.\nexport first_address=$(bitcoin-cli -testnet -rpcwallet=multisig2of2withBDK getnewaddress) echo $first_address BDK In BDK Bob can specify directly the descriptors on the command line to produce the multisig address, because BDK is descriptors aware natively.\nrepl -d \u0026quot;$BDK_rec_desc_chksum\u0026quot; -c \u0026quot;$BDK_chg_desc_chksum\u0026quot; -n testnet -w $BDK_fingerprint get_new_address` Et voil√†: if we have done everything correctly, the newly created address in Core is the same of the newly created address in BDK. this is part of the \u0026ldquo;miracle\u0026rdquo; of descriptors' interoperability.\nWe ask for testnet coins giving the first created address. To find testnet coins for free, you can just google \u0026ldquo;testnet faucet\u0026rdquo; and you should find some satoshis to play with. Just give to the site your first generated address and, in twenty minutes, you will find the satoshis in your balance both in Core and in BDK.\n# to check it in Core: bitcoin-cli -testnet -rpcwallet=multisig2of2withBDK getbalance # In BDK: # Sync with the blockchain repl -d \u0026quot;$BDK_rec_desc_chksum\u0026quot; -c \u0026quot;$BDK_chg_desc_chksum\u0026quot; -n testnet -w $BDK_fingerprint sync # Get the balance repl -d \u0026quot;$BDK_rec_desc_chksum\u0026quot; -c \u0026quot;$BDK_chg_desc_chksum\u0026quot; -n testnet -w $BDK_fingerprint get_balance Some testnet faucets have an address to send back the unused satoshi after the use. Take note of that because we will use it in the next step.\n4. we return part of the satoshis received back to the faucet export psbt=$(bitcoin-cli -testnet -rpcwallet=multisig2of2withBDK walletcreatefundedpsbt \u0026quot;[]\u0026quot; \u0026quot;[{\\\u0026quot;tb1qrcesfj9f2d7x40xs6ztnlrcgxhh6vsw8658hjdhdy6qgkf6nfrds9rp79a\\\u0026quot;:0.000012}]\u0026quot;|jq -r '.psbt') export psbt=$(bitcoin-cli -testnet -rpcwallet=multisig2of2withBDK walletprocesspsbt $psbt|jq -r '.psbt') { \u0026quot;psbt\u0026quot;: \u0026quot;cHNidP8BAIkCAAAAATj90EC+NAuXj7y6SseZJucoJM6sGnUcVm9koTveZECTAAAAAAD+////AmACAAAAAAAAIgAg98ol9j4AalD71E0mV5QV0uM6/vCT+pi2twxr/zrvLROwBAAAAAAAACIAIB4zBMipU3xqvNDQlz+PCDXvpkHH1Q95Nu0mgIsnU0jbAAAAAAABAIkCAAAAAQS+ObgGG6UwtvaO3KYph2E3/ws7Q83RbmR3rxC0fKYSAQAAAAD+////AtAHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNDAHQAAAAAAACIAIBQpiDTgPIMt0ld8cmuYqlY+EIPjvrmMqZruDhs61hQNAAAAAAEBK9AHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNAiAgNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfUcwRAIgS6x0i1J1HRzllIPf4WlFY+Dl8kCCLK81TL2djZxTFXMCICJVBKkKNxu1w1mRVor6iFTSVXiJjmWwBXVeJLISvBwAAQEFR1IhArn3tec7n7318rnWqf0dIIwtLtfxo6Zt0HV70UvZYaWvIQNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfVKuIgYCufe15zufvfXyudap/R0gjC0u1/Gjpm3QdXvRS9lhpa8YNEw2cFQAAIAAAACAAAAAgAAAAAAAAAAAIgYDbdI+wHtIgO6pS6Ja7jai1pDwPeidKoDCytTO1jhjAH0YO/laXFQAAIAAAACAAAAAgAAAAAAAAAAAAAEBR1IhAqccvA3rL13D1K4GeWjcahDsO3P8oaVNBttk4MlCKXIcIQLHKhjmPuCQjyS77ZfaMN2tdgNKcf/+57VXGZhz/UWTl1KuIgICpxy8DesvXcPUrgZ5aNxqEOw7c/yhpU0G22TgyUIpchwYNEw2cFQAAIAAAACAAAAAgAEAAAADAAAAIgICxyoY5j7gkI8ku+2X2jDdrXYDSnH//ue1VxmYc/1Fk5cYO/laXFQAAIAAAACAAAAAgAEAAAADAAAAAAA=\u0026quot;, \u0026quot;complete\u0026quot;: false } Exactly! Note the \u0026quot;complete\u0026quot;: false. We have processed the transaction with Core but we miss one of the necessary key of the multisig 2of2 setup (The one contained inside BDK).\ntb1qrcesfj9f2d7x40xs6ztnlrcgxhh6vsw8658hjdhdy6qgkf6nfrds9rp79a is the address we got from the faucet site to return the satoshis.\nThe PSBT is sent over to the BDK wallet owner who tries to sign the transaction:\nrepl -d \u0026quot;$BDK_rec_desc_chksum\u0026quot; -c \u0026quot;$BDK_chg_desc_chksum\u0026quot; -n testnet -w $BDK_fingerprint sign --psbt $psbt { \u0026quot;is_finalized\u0026quot;: true, \u0026quot;psbt\u0026quot;: \u0026quot;cHNidP8BAIkCAAAAATj90EC+NAuXj7y6SseZJucoJM6sGnUcVm9koTveZECTAAAAAAD+////AmACAAAAAAAAIgAg98ol9j4AalD71E0mV5QV0uM6/vCT+pi2twxr/zrvLROwBAAAAAAAACIAIB4zBMipU3xqvNDQlz+PCDXvpkHH1Q95Nu0mgIsnU0jbAAAAAAABAIkCAAAAAQS+ObgGG6UwtvaO3KYph2E3/ws7Q83RbmR3rxC0fKYSAQAAAAD+////AtAHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNDAHQAAAAAAACIAIBQpiDTgPIMt0ld8cmuYqlY+EIPjvrmMqZruDhs61hQNAAAAAAEBK9AHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNAiAgNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfUcwRAIgS6x0i1J1HRzllIPf4WlFY+Dl8kCCLK81TL2djZxTFXMCICJVBKkKNxu1w1mRVor6iFTSVXiJjmWwBXVeJLISvBwAASICArn3tec7n7318rnWqf0dIIwtLtfxo6Zt0HV70UvZYaWvRzBEAiBkVDLgVEwvENnLx+04o7gGpGjFDBwAXTJmf8Yvo35oygIgbuBkHsvPC9jmZcMZ9P+Pwp01yxSaWo+5feyPmd3ai1kBAQVHUiECufe15zufvfXyudap/R0gjC0u1/Gjpm3QdXvRS9lhpa8hA23SPsB7SIDuqUuiWu42otaQ8D3onSqAwsrUztY4YwB9Uq4iBgNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfRg7+VpcVAAAgAAAAIAAAACAAAAAAAAAAAAiBgK597XnO5+99fK51qn9HSCMLS7X8aOmbdB1e9FL2WGlrxg0TDZwVAAAgAAAAIAAAACAAAAAAAAAAAABBwABCNoEAEcwRAIgZFQy4FRMLxDZy8ftOKO4BqRoxQwcAF0yZn/GL6N+aMoCIG7gZB7LzwvY5mXDGfT/j8KdNcsUmlqPuX3sj5nd2otZAUcwRAIgS6x0i1J1HRzllIPf4WlFY+Dl8kCCLK81TL2djZxTFXMCICJVBKkKNxu1w1mRVor6iFTSVXiJjmWwBXVeJLISvBwAAUdSIQK597XnO5+99fK51qn9HSCMLS7X8aOmbdB1e9FL2WGlryEDbdI+wHtIgO6pS6Ja7jai1pDwPeidKoDCytTO1jhjAH1SrgABAUdSIQKnHLwN6y9dw9SuBnlo3GoQ7Dtz/KGlTQbbZODJQilyHCECxyoY5j7gkI8ku+2X2jDdrXYDSnH//ue1VxmYc/1Fk5dSriICAqccvA3rL13D1K4GeWjcahDsO3P8oaVNBttk4MlCKXIcGDRMNnBUAACAAAAAgAAAAIABAAAAAwAAACICAscqGOY+4JCPJLvtl9ow3a12A0px//7ntVcZmHP9RZOXGDv5WlxUAACAAAAAgAAAAIABAAAAAwAAAAAA\u0026quot; } The signature has succeded (note the \u0026ldquo;is_finalized\u0026rdquo;: true,) and now we can broadcast the transction.\nrepl -d \u0026quot;$BDK_rec_desc_chksum\u0026quot; -c \u0026quot;$BDK_chg_desc_chksum\u0026quot; -n testnet -w $BDK_fingerprint broadcast --psbt \u0026quot;cHNidP8BAIkCAAAAATj90EC+NAuXj7y6SseZJucoJM6sGnUcVm9koTveZECTAAAAAAD+////AmACAAAAAAAAIgAg98ol9j4AalD71E0mV5QV0uM6/vCT+pi2twxr/zrvLROwBAAAAAAAACIAIB4zBMipU3xqvNDQlz+PCDXvpkHH1Q95Nu0mgIsnU0jbAAAAAAABAIkCAAAAAQS+ObgGG6UwtvaO3KYph2E3/ws7Q83RbmR3rxC0fKYSAQAAAAD+////AtAHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNDAHQAAAAAAACIAIBQpiDTgPIMt0ld8cmuYqlY+EIPjvrmMqZruDhs61hQNAAAAAAEBK9AHAAAAAAAAIgAg6GXadcNj7k4yKUbnVlTLiedXQFXYdCBoNygop/PISNAiAgNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfUcwRAIgS6x0i1J1HRzllIPf4WlFY+Dl8kCCLK81TL2djZxTFXMCICJVBKkKNxu1w1mRVor6iFTSVXiJjmWwBXVeJLISvBwAASICArn3tec7n7318rnWqf0dIIwtLtfxo6Zt0HV70UvZYaWvRzBEAiBkVDLgVEwvENnLx+04o7gGpGjFDBwAXTJmf8Yvo35oygIgbuBkHsvPC9jmZcMZ9P+Pwp01yxSaWo+5feyPmd3ai1kBAQVHUiECufe15zufvfXyudap/R0gjC0u1/Gjpm3QdXvRS9lhpa8hA23SPsB7SIDuqUuiWu42otaQ8D3onSqAwsrUztY4YwB9Uq4iBgNt0j7Ae0iA7qlLolruNqLWkPA96J0qgMLK1M7WOGMAfRg7+VpcVAAAgAAAAIAAAACAAAAAAAAAAAAiBgK597XnO5+99fK51qn9HSCMLS7X8aOmbdB1e9FL2WGlrxg0TDZwVAAAgAAAAIAAAACAAAAAAAAAAAABBwABCNoEAEcwRAIgZFQy4FRMLxDZy8ftOKO4BqRoxQwcAF0yZn/GL6N+aMoCIG7gZB7LzwvY5mXDGfT/j8KdNcsUmlqPuX3sj5nd2otZAUcwRAIgS6x0i1J1HRzllIPf4WlFY+Dl8kCCLK81TL2djZxTFXMCICJVBKkKNxu1w1mRVor6iFTSVXiJjmWwBXVeJLISvBwAAUdSIQK597XnO5+99fK51qn9HSCMLS7X8aOmbdB1e9FL2WGlryEDbdI+wHtIgO6pS6Ja7jai1pDwPeidKoDCytTO1jhjAH1SrgABAUdSIQKnHLwN6y9dw9SuBnlo3GoQ7Dtz/KGlTQbbZODJQilyHCECxyoY5j7gkI8ku+2X2jDdrXYDSnH//ue1VxmYc/1Fk5dSriICAqccvA3rL13D1K4GeWjcahDsO3P8oaVNBttk4MlCKXIcGDRMNnBUAACAAAAAgAAAAIABAAAAAwAAACICAscqGOY+4JCPJLvtl9ow3a12A0px//7ntVcZmHP9RZOXGDv5WlxUAACAAAAAgAAAAIABAAAAAwAAAAAA\u0026quot; { \u0026quot;txid\u0026quot;: \u0026quot;a0b082e3b0579822d4a0b0fa95a4c4662f6b128ffd43fdcfe53c37473ce85dee\u0026quot; } Conclusion We have built an HDM and we have used it with two indipendent wallets, which are compatible with BIP 174 and Output Descriptors. Hopefully we will see many other compatible wallets beyound Bitcoin Core and BDK, with which we will be able to easily set up multi signature schemes.\n"
},
{
	"uri": "https://bitcoindevkit.org/blog/author/gabriele-domenichini/",
	"title": "Gabriele Domenichini",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/blog/tags/guide/",
	"title": "guide",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://bitcoindevkit.org/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "Bitcoin Dev Kit The Bitcoin Dev Kit (BDK) project (originally called Magical Bitcoin üßô) aims to build a collection of tools and libraries that are designed to be a solid foundation for cross platform Bitcoin wallets, along with a fully working reference implementation wallet called Magical Bitcoin. All BDK components are designed to be lightweight and modular so that they can be adapted for virtually any use-case: from single-sig mobile wallets to multi-billion-dollar cold storage vaults.\nThe main long-term goal is to concentrate the development efforts of multiple people and companies into one open source and very well reviewed project, instead of dispersing them over multiple closed/semi-closed or poorly designed projects.\nKeep in mind that this project is still in a very early phase of development. The APIs and the general architecture shouldn\u0026rsquo;t be considered stable yet. At the moment most of the code is concentrated in the main repo and is slowly being refactored and taken out into separate, independent modules.\n Playground As a way of demonstrating the flexibly of this project, a minimalistic command line tool (also called \u0026ldquo;repl\u0026rdquo;) is available as a debugging tool in the main bdk repo. It has been compiled to WebAssembly and can be used directly from the browser. See the playground section to give it a try!\nThe playground relies on Esplora to monitor the blockchain and is currently locked in testnet-only mode, for obvious safety reasons. The native command line tool can also be used in regtest mode when installed on a computer. See the REPL section to learn more.\nDescriptors One of the original milestones of this project was to provide wallets with \u0026ldquo;almost magically\u0026rdquo; support for very complex spending policies, without having to individually translate them into code. It may sound disappointing, but there isn\u0026rsquo;t, in fact, any real magic in this wallet: the generalization is achieved thanks to descriptors, that are now slowly starting to see adoption in a few other Bitcoin projects as well.\nThe author of this project strongly believes descriptors will be a big part of the future generation of Bitcoin wallets, since they provide a very flexible scripting language that can also be extended as the technology and tooling of Bitcoin evolves and changes (Schnorr signatures, Taproot, etc).\nTo learn more, check out the specific Descriptors section.\n"
}]