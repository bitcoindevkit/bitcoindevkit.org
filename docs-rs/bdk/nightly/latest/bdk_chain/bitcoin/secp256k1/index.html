<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust bindings for Pieter Wuille’s secp256k1 library, which is used for fast and accurate manipulation of ECDSA signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives."><title>bdk_chain::bitcoin::secp256k1 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bdk_chain" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (78a775127 2024-05-11)" data-channel="nightly" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../../bdk_chain/index.html"><img src="https://github.com/bitcoindevkit/bdk/raw/master/static/bdk.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../bdk_chain/index.html"><img src="https://github.com/bitcoindevkit/bdk/raw/master/static/bdk.png" alt="logo"></a><h2><a href="../../../bdk_chain/index.html">bdk_chain</a><span class="version">0.20.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In bdk_chain::bitcoin</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../index.html">bdk_chain</a>::<wbr><a href="../index.html">bitcoin</a>::<wbr><a class="mod" href="#">secp256k1</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust bindings for Pieter Wuille’s secp256k1 library, which is used for
fast and accurate manipulation of ECDSA signatures on the secp256k1
curve. Such signatures are used extensively by the Bitcoin network
and its derivatives.</p>
<p>To minimize dependencies, some functions are feature-gated. To generate
random keys or to re-randomize a context object, compile with the
<code>rand-std</code> feature. If you are willing to use the <code>rand-std</code> feature, we
have enabled an additional defense-in-depth sidechannel protection for
our context objects, which re-blinds certain operations on secret key
data. To de/serialize objects with serde, compile with “serde”.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus
encoding!</p>
<p>Where possible, the bindings use the Rust type system to ensure that
API usage errors are impossible. For example, the library uses context
objects that contain precomputation tables which are created on object
construction. Since this is a slow operation (10+ milliseconds, vs ~50
microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ)
the tables are optional, giving a performance boost for users who only
care about signing, only care about verification, or only care about
parsing. In the upstream library, if you attempt to sign a message using
a context that does not support this, it will trigger an assertion
failure and terminate the program. In <code>rust-secp256k1</code>, this is caught
at compile-time; in fact, it is impossible to compile code that will
trigger any assertion failures in the upstream library.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::rand::rngs::OsRng;
<span class="kw">use </span>secp256k1::{Secp256k1, Message};
<span class="kw">use </span>secp256k1::hashes::{sha256, Hash};

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>(secret_key, public_key) = secp.generate_keypair(<span class="kw-2">&amp;mut </span>OsRng);
<span class="kw">let </span>digest = sha256::Hash::hash(<span class="string">"Hello World!"</span>.as_bytes());
<span class="kw">let </span>message = Message::from_digest(digest.to_byte_array());

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>If the “global-context” feature is enabled you have access to an alternate API.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{generate_keypair, Message};
<span class="kw">use </span>secp256k1::hashes::{sha256, Hash};

<span class="kw">let </span>(secret_key, public_key) = generate_keypair(<span class="kw-2">&amp;mut </span>rand::thread_rng());
<span class="kw">let </span>digest = sha256::Hash::hash(<span class="string">"Hello World!"</span>.as_bytes());
<span class="kw">let </span>message = Message::from_digest(digest.to_byte_array());

<span class="kw">let </span>sig = secret_key.sign_ecdsa(message);
<span class="macro">assert!</span>(sig.verify(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>The above code requires <code>rust-secp256k1</code> to be compiled with the <code>rand-std</code> and <code>hashes-std</code>
feature enabled, to get access to <a href="struct.Secp256k1.html#method.generate_keypair"><code>generate_keypair</code></a>
Alternately, keys and messages can be parsed from slices, like</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, SecretKey, PublicKey};

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>secret_key = SecretKey::from_slice(<span class="kw-2">&amp;</span>[<span class="number">0xcd</span>; <span class="number">32</span>]).expect(<span class="string">"32 bytes, within curve order"</span>);
<span class="kw">let </span>public_key = PublicKey::from_secret_key(<span class="kw-2">&amp;</span>secp, <span class="kw-2">&amp;</span>secret_key);
<span class="comment">// This is unsafe unless the supplied byte slice is the output of a cryptographic hash function.
// See the above example for how to use this library together with `hashes-std`.
</span><span class="kw">let </span>message = Message::from_digest_slice(<span class="kw-2">&amp;</span>[<span class="number">0xab</span>; <span class="number">32</span>]).expect(<span class="string">"32 bytes"</span>);

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Users who only want to verify signatures can use a cheaper context, like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, ecdsa, PublicKey};

<span class="kw">let </span>secp = Secp256k1::verification_only();

<span class="kw">let </span>public_key = PublicKey::from_slice(<span class="kw-2">&amp;</span>[
    <span class="number">0x02</span>,
    <span class="number">0xc6</span>, <span class="number">0x6e</span>, <span class="number">0x7d</span>, <span class="number">0x89</span>, <span class="number">0x66</span>, <span class="number">0xb5</span>, <span class="number">0xc5</span>, <span class="number">0x55</span>,
    <span class="number">0xaf</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0x98</span>, <span class="number">0x9d</span>, <span class="number">0xa9</span>, <span class="number">0xfb</span>, <span class="number">0xf8</span>,
    <span class="number">0xdb</span>, <span class="number">0x95</span>, <span class="number">0xe1</span>, <span class="number">0x56</span>, <span class="number">0x31</span>, <span class="number">0xce</span>, <span class="number">0x35</span>, <span class="number">0x8c</span>,
    <span class="number">0x3a</span>, <span class="number">0x17</span>, <span class="number">0x10</span>, <span class="number">0xc9</span>, <span class="number">0x62</span>, <span class="number">0x67</span>, <span class="number">0x90</span>, <span class="number">0x63</span>,
]).expect(<span class="string">"public keys must be 33 or 65 bytes, serialized according to SEC 2"</span>);

<span class="kw">let </span>message = Message::from_digest_slice(<span class="kw-2">&amp;</span>[
    <span class="number">0xaa</span>, <span class="number">0xdf</span>, <span class="number">0x7d</span>, <span class="number">0xe7</span>, <span class="number">0x82</span>, <span class="number">0x03</span>, <span class="number">0x4f</span>, <span class="number">0xbe</span>,
    <span class="number">0x3d</span>, <span class="number">0x3d</span>, <span class="number">0xb2</span>, <span class="number">0xcb</span>, <span class="number">0x13</span>, <span class="number">0xc0</span>, <span class="number">0xcd</span>, <span class="number">0x91</span>,
    <span class="number">0xbf</span>, <span class="number">0x41</span>, <span class="number">0xcb</span>, <span class="number">0x08</span>, <span class="number">0xfa</span>, <span class="number">0xc7</span>, <span class="number">0xbd</span>, <span class="number">0x61</span>,
    <span class="number">0xd5</span>, <span class="number">0x44</span>, <span class="number">0x53</span>, <span class="number">0xcf</span>, <span class="number">0x6e</span>, <span class="number">0x82</span>, <span class="number">0xb4</span>, <span class="number">0x50</span>,
]).expect(<span class="string">"messages must be 32 bytes and are expected to be hashes"</span>);

<span class="kw">let </span>sig = ecdsa::Signature::from_compact(<span class="kw-2">&amp;</span>[
    <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0xc2</span>, <span class="number">0x64</span>, <span class="number">0xa9</span>, <span class="number">0xfe</span>, <span class="number">0xf1</span>, <span class="number">0x7a</span>,
    <span class="number">0x3f</span>, <span class="number">0x25</span>, <span class="number">0x34</span>, <span class="number">0x49</span>, <span class="number">0xcf</span>, <span class="number">0x8c</span>, <span class="number">0x39</span>, <span class="number">0x7a</span>,
    <span class="number">0xb6</span>, <span class="number">0xf1</span>, <span class="number">0x6f</span>, <span class="number">0xb3</span>, <span class="number">0xd6</span>, <span class="number">0x3d</span>, <span class="number">0x86</span>, <span class="number">0x94</span>,
    <span class="number">0x0b</span>, <span class="number">0x55</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x3d</span>, <span class="number">0xfd</span>, <span class="number">0x02</span>, <span class="number">0xae</span>,
    <span class="number">0x3b</span>, <span class="number">0x46</span>, <span class="number">0x1b</span>, <span class="number">0xb4</span>, <span class="number">0x33</span>, <span class="number">0x6b</span>, <span class="number">0x5e</span>, <span class="number">0xcb</span>,
    <span class="number">0xae</span>, <span class="number">0xfd</span>, <span class="number">0x66</span>, <span class="number">0x27</span>, <span class="number">0xaa</span>, <span class="number">0x92</span>, <span class="number">0x2e</span>, <span class="number">0xfc</span>,
    <span class="number">0x04</span>, <span class="number">0x8f</span>, <span class="number">0xec</span>, <span class="number">0x0c</span>, <span class="number">0x88</span>, <span class="number">0x1c</span>, <span class="number">0x10</span>, <span class="number">0xc4</span>,
    <span class="number">0xc9</span>, <span class="number">0x42</span>, <span class="number">0x8f</span>, <span class="number">0xca</span>, <span class="number">0x69</span>, <span class="number">0xc1</span>, <span class="number">0x32</span>, <span class="number">0xa2</span>,
]).expect(<span class="string">"compact signatures are 64 bytes; DER signatures are 68-72 bytes"</span>);

<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Observe that the same code using, say <a href="struct.Secp256k1.html#method.signing_only"><code>signing_only</code></a>
to generate a context would simply not compile.</p>
<h3 id="crate-featuresoptional-dependencies"><a class="doc-anchor" href="#crate-featuresoptional-dependencies">§</a>Crate features/optional dependencies</h3>
<p>This crate provides the following opt-in Cargo features:</p>
<ul>
<li><code>std</code> - use standard Rust library, enabled by default.</li>
<li><code>alloc</code> - use the <code>alloc</code> standard Rust library to provide heap allocations.</li>
<li><code>rand</code> - use <code>rand</code> library to provide random generator (e.g. to generate keys).</li>
<li><code>rand-std</code> - use <code>rand</code> library with its <code>std</code> feature enabled. (Implies <code>rand</code>.)</li>
<li><code>hashes</code> - use the <code>hashes</code> library.</li>
<li><code>hashes-std</code> - use the <code>hashes</code> library with its <code>std</code> feature enabled (implies <code>hashes</code>).</li>
<li><code>recovery</code> - enable functions that can compute the public key from signature.</li>
<li><code>lowmemory</code> - optimize the library for low-memory environments.</li>
<li><code>global-context</code> - enable use of global secp256k1 context (implies <code>std</code>).</li>
<li><code>serde</code> - implements serialization and deserialization for types in this crate using <code>serde</code>.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus encoding!</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="constants/index.html" title="mod bdk_chain::bitcoin::secp256k1::constants">constants</a></div><div class="desc docblock-short">Constants related to the API and the underlying curve.</div></li><li><div class="item-name"><a class="mod" href="ecdh/index.html" title="mod bdk_chain::bitcoin::secp256k1::ecdh">ecdh</a></div><div class="desc docblock-short">Support for shared secret computations.</div></li><li><div class="item-name"><a class="mod" href="ecdsa/index.html" title="mod bdk_chain::bitcoin::secp256k1::ecdsa">ecdsa</a></div><div class="desc docblock-short">Structs and functionality related to the ECDSA signature algorithm.</div></li><li><div class="item-name"><a class="mod" href="ellswift/index.html" title="mod bdk_chain::bitcoin::secp256k1::ellswift">ellswift</a></div><div class="desc docblock-short">This module provides an implementation of ElligatorSwift as well as a
version of x-only ECDH using it (including compatibility with BIP324).</div></li><li><div class="item-name"><a class="mod" href="ffi/index.html" title="mod bdk_chain::bitcoin::secp256k1::ffi">ffi</a></div><div class="desc docblock-short">secp256k1-sys FFI bindings</div></li><li><div class="item-name"><a class="mod" href="hashes/index.html" title="mod bdk_chain::bitcoin::secp256k1::hashes">hashes</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Deprecated reexport of the <code>bitcoin-hashes</code> crate.</div></li><li><div class="item-name"><a class="mod" href="rand/index.html" title="mod bdk_chain::bitcoin::secp256k1::rand">rand</a></div><div class="desc docblock-short">Utilities for random number generation</div></li><li><div class="item-name"><a class="mod" href="scalar/index.html" title="mod bdk_chain::bitcoin::secp256k1::scalar">scalar</a></div><div class="desc docblock-short">Provides <a href="struct.Scalar.html" title="struct bdk_chain::bitcoin::secp256k1::Scalar"><code>Scalar</code></a> and related types.</div></li><li><div class="item-name"><a class="mod" href="schnorr/index.html" title="mod bdk_chain::bitcoin::secp256k1::schnorr">schnorr</a></div><div class="desc docblock-short">Support for schnorr signatures.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.impl_array_newtype.html" title="macro bdk_chain::bitcoin::secp256k1::impl_array_newtype">impl_array_newtype</a></div><div class="desc docblock-short">Implement methods and traits for types that contain an inner array.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AllPreallocated.html" title="struct bdk_chain::bitcoin::secp256k1::AllPreallocated">AllPreallocated</a></div><div class="desc docblock-short">Represents the set of all capabilities (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.InvalidParityValue.html" title="struct bdk_chain::bitcoin::secp256k1::InvalidParityValue">InvalidParityValue</a></div><div class="desc docblock-short">Error returned when conversion from an integer to <code>Parity</code> fails.</div></li><li><div class="item-name"><a class="struct" href="struct.Keypair.html" title="struct bdk_chain::bitcoin::secp256k1::Keypair">Keypair</a></div><div class="desc docblock-short">Opaque data structure that holds a keypair consisting of a secret and a public key.</div></li><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct bdk_chain::bitcoin::secp256k1::Message">Message</a></div><div class="desc docblock-short">A (hashed) message input to an ECDSA signature.</div></li><li><div class="item-name"><a class="struct" href="struct.PublicKey.html" title="struct bdk_chain::bitcoin::secp256k1::PublicKey">PublicKey</a></div><div class="desc docblock-short">Public key - used to verify ECDSA signatures and to do Taproot tweaks.</div></li><li><div class="item-name"><a class="struct" href="struct.Scalar.html" title="struct bdk_chain::bitcoin::secp256k1::Scalar">Scalar</a></div><div class="desc docblock-short">Positive 256-bit integer guaranteed to be less than the secp256k1 curve order.</div></li><li><div class="item-name"><a class="struct" href="struct.Secp256k1.html" title="struct bdk_chain::bitcoin::secp256k1::Secp256k1">Secp256k1</a></div><div class="desc docblock-short">The secp256k1 engine, used to execute all signature operations.</div></li><li><div class="item-name"><a class="struct" href="struct.SecretKey.html" title="struct bdk_chain::bitcoin::secp256k1::SecretKey">SecretKey</a></div><div class="desc docblock-short">Secret key - a 256-bit key used to create ECDSA and Taproot signatures.</div></li><li><div class="item-name"><a class="struct" href="struct.SignOnlyPreallocated.html" title="struct bdk_chain::bitcoin::secp256k1::SignOnlyPreallocated">SignOnlyPreallocated</a></div><div class="desc docblock-short">Represents the set of capabilities needed for signing (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.VerifyOnlyPreallocated.html" title="struct bdk_chain::bitcoin::secp256k1::VerifyOnlyPreallocated">VerifyOnlyPreallocated</a></div><div class="desc docblock-short">Represents the set of capabilities needed for verification (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.XOnlyPublicKey.html" title="struct bdk_chain::bitcoin::secp256k1::XOnlyPublicKey">XOnlyPublicKey</a></div><div class="desc docblock-short">An x-only public key, used for verification of Taproot signatures and serialized according to BIP-340.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.All.html" title="enum bdk_chain::bitcoin::secp256k1::All">All</a></div><div class="desc docblock-short">Represents the set of all capabilities.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum bdk_chain::bitcoin::secp256k1::Error">Error</a></div><div class="desc docblock-short">The main error type for this library.</div></li><li><div class="item-name"><a class="enum" href="enum.Parity.html" title="enum bdk_chain::bitcoin::secp256k1::Parity">Parity</a></div><div class="desc docblock-short">Represents the parity passed between FFI function calls.</div></li><li><div class="item-name"><a class="enum" href="enum.SignOnly.html" title="enum bdk_chain::bitcoin::secp256k1::SignOnly">SignOnly</a></div><div class="desc docblock-short">Represents the set of capabilities needed for signing.</div></li><li><div class="item-name"><a class="enum" href="enum.VerifyOnly.html" title="enum bdk_chain::bitcoin::secp256k1::VerifyOnly">VerifyOnly</a></div><div class="desc docblock-short">Represents the set of capabilities needed for verification.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Context.html" title="trait bdk_chain::bitcoin::secp256k1::Context">Context</a></div><div class="desc docblock-short">A trait for all kinds of contexts that lets you define the exact flags and a function to
deallocate memory. It isn’t possible to implement this for types outside this crate.</div></li><li><div class="item-name"><a class="trait" href="trait.PreallocatedContext.html" title="trait bdk_chain::bitcoin::secp256k1::PreallocatedContext">PreallocatedContext</a></div><div class="desc docblock-short">Trait marking that a particular context object internally points to
memory that must outlive <code>'a</code></div></li><li><div class="item-name"><a class="trait" href="trait.Signing.html" title="trait bdk_chain::bitcoin::secp256k1::Signing">Signing</a></div><div class="desc docblock-short">Marker trait for indicating that an instance of <a href="../key/struct.Secp256k1.html" title="struct bdk_chain::bitcoin::key::Secp256k1"><code>Secp256k1</code></a> can be used for signing.</div></li><li><div class="item-name"><a class="trait" href="trait.ThirtyTwoByteHash.html" title="trait bdk_chain::bitcoin::secp256k1::ThirtyTwoByteHash">ThirtyTwoByteHash</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Trait describing something that promises to be a 32-byte random number; in particular,
it has negligible probability of being zero or overflowing the group order. Such objects
may be converted to <code>Message</code>s without any error paths.</div></li><li><div class="item-name"><a class="trait" href="trait.Verification.html" title="trait bdk_chain::bitcoin::secp256k1::Verification">Verification</a></div><div class="desc docblock-short">Marker trait for indicating that an instance of <a href="../key/struct.Secp256k1.html" title="struct bdk_chain::bitcoin::key::Secp256k1"><code>Secp256k1</code></a> can be used for verification.</div></li></ul></section></div></main></body></html>